-- Metatable example: Vector operations
Vector = {}
Vector.__index = Vector

function Vector.new(x, y, z)
    local vec = {x = x or 0, y = y or 0, z = z or 0}
    setmetatable(vec, Vector)
    return vec
end

function Vector:__add(other)
    return Vector.new(self.x + other.x, self.y + other.y, self.z + other.z)
end

function Vector:__sub(other)
    return Vector.new(self.x - other.x, self.y - other.y, self.z - other.z)
end

function Vector:__tostring()
    return "(" .. self.x .. ", " .. self.y .. ", " .. self.z .. ")"
end

function Vector:__call()
    print( "Vector called with: ", self )
end

-- Using the vector class
local v1 = Vector.new(1, 2, 3)
local v2 = Vector.new(4, 5, 6)
local v3 = v1 + v2
print("Vector Addition: " .. tostring(v3))
local v4 = v2 - v1
print("Vector Subtraction: " .. tostring(v4))

v1()


-- Closure example: Counter
function create_counter(start)
    local count = start or 0
    return function(increment)
        count = count + (increment or 1)
        return count
    end
end

local counter1 = create_counter(10)
local counter2 = create_counter(100)

print("Counter 1:", counter1(2))  -- 12
print("Counter 1:", counter1(3))  -- 15
print("Counter 2:", counter2(5))  -- 105
print("Counter 2:", counter2(10)) -- 115


-- Table manipulation and recursive function example: Merge Sort
function merge_sort(arr)
    if #arr <= 1 then
        return arr
    end

    local mid = math.floor(#arr / 2)
    local left = merge_sort({table.unpack(arr, 1, mid)})
    local right = merge_sort({table.unpack(arr, mid + 1, #arr)})

    return merge(left, right)
end

function merge(left, right)
    local result = {}
    local i, j = 1, 1

    while i <= #left and j <= #right do
        if left[i] < right[j] then
            table.insert(result, left[i])
            i = i + 1
        else
            table.insert(result, right[j])
            j = j + 1
        end
    end

    while i <= #left do
        table.insert(result, left[i])
        i = i + 1
    end

    while j <= #right do
        table.insert(result, right[j])
        j = j + 1
    end

    return result
end

-- Test merge sort
local unsorted = {38, 27, 43, 3, 9, 82, 10}
local sorted = merge_sort(unsorted)
print("Sorted Array:")
print( table.concat(sorted, ", ") )
for idx, v in ipairs(sorted) do
    print(idx, v)
end



-- Coroutine example: Fibonacci generator
-- function fibonacci()
--     local a, b = 0, 1
--     return coroutine.create(function()
--         while true do
--             coroutine.yield(a)
--             a, b = b, a + b
--         end
--     end)
-- end

-- local fib = fibonacci()
-- for i = 1, 10 do
--     local success, value = coroutine.resume(fib)
--     print("Fibonacci number " .. i .. ": " .. value)
-- end


--[===[
This code was generated by ChatGPT4o

Explanation of the code components:
Vector Operations with Metatables:

Defines a Vector class using metatables for vector addition, subtraction, and string representation.
The vectors are used and printed to demonstrate their operations.
Closure Example (Counter):

A create_counter function that creates a closure, allowing state to persist across function calls.
Coroutine Example (Fibonacci Generator):

An implementation of merge sort, demonstrating recursion, table manipulation, and table sorting.
This code combines many Lua features and should thoroughly test your Lua parser! Let me know if you'd like any modifications or additional features added.

A Fibonacci number generator using coroutines, yielding the next number in the sequence on each resume.
Recursive Function (Merge Sort):
]===]