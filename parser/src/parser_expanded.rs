// This file was generated by rustylr 1.10.0
// This generated code is targeting rusty_lr version 3.18.0.
// There might be a build error if the version is not matched.
//
// Input file: parser.rs
// Output file: parser_expanded.rs
// ================================User Codes Begin================================
use crate::expression;
use crate::statement;
use crate::ChunkOrExpressions;
use crate::Expression;
use crate::ParseError;
use crate::Span;
use crate::SpannedString;
use crate::Statement;
use lua_tokenizer::Token;
use lua_tokenizer::TokenType;
macro_rules! new_binary_node {
    ($ variant : ident , $ op : ident , $ lhs : ident , $ rhs : ident) => {{
        let span = $lhs.span().merge_ordered(&$rhs.span());
        let span_op = $op.span();
        let binary_data = expression::ExprBinaryData::new($lhs, $rhs, span, span_op);
        Expression::Binary(expression::ExprBinary::$variant(binary_data))
    }};
}
macro_rules! new_unary_node {
    ($ variant : ident , $ op : ident , $ lhs : ident) => {{
        let span = $op.span().merge_ordered(&$lhs.span());
        let span_op = $op.span();
        let unary_data = expression::ExprUnaryData::new($lhs, span, span_op);
        Expression::Unary(expression::ExprUnary::$variant(unary_data))
    }};
}
fn filter(token: &Token) -> &TokenType {
    &token.token_type
}
// =================================User Codes End=================================
/*
====================================Grammar=====================================

# of terminal classes: 59
# of states: 226

ChunkOrExpressions -> Chunk
ChunkOrExpressions -> ExpList1
Chunk -> Block
Block -> Statement* ReturnStatement?
Statement -> semicolon
Statement -> VarList equal ExpList1
Statement -> FunctionCall
Statement -> coloncolon ident coloncolon
Statement -> break_
Statement -> goto_ ident
Statement -> do_ Block end_
Statement -> while_ Exp do_ Block end_
Statement -> repeat_ Block until_ Exp
Statement -> if_ Exp then_ Block ElseIf* (else_, Block)? end_
Statement -> for_ ident equal Exp comma Exp (comma, Exp)? do_ Block end_
Statement -> for_ NameList in_ ExpList1 do_ Block end_
Statement -> function_ FuncName FuncBody
Statement -> local_ function_ ident FuncBody
Statement -> local_ AttNameList (equal, ExpList1)?
ElseIf -> elseif_ Exp then_ Block
ReturnStatement -> return_ ExpList0 semicolon?
Var -> ident
Var -> PrefixExp lbracket Exp rbracket
Var -> PrefixExp dot ident
PrefixExp -> Var
PrefixExp -> FunctionCall
PrefixExp -> lparen Exp rparen
FunctionCall -> PrefixExp Args
FunctionCall -> PrefixExp colon ident Args
Args -> lparen ExpList0 rparen
Args -> TableConstructor
Args -> string_literal
VarList -> VarList comma Var
VarList -> Var
ExpList1 -> ExpList1 comma Exp
ExpList1 -> Exp
ExpList0 -> ExpList1
ExpList0 ->
NameList -> NameList comma ident
NameList -> ident
AttName -> ident Attrib
AttNameList -> AttNameList comma AttName
AttNameList -> AttName
Attrib -> less ident greater
Attrib ->
Exp -> numeric_literal
Exp -> nil
Exp -> string_literal
Exp -> bool_
Exp -> dotdotdot
Exp -> FunctionDef
Exp -> PrefixExp
Exp -> TableConstructor
Exp -> not_ Exp
Exp -> hash Exp
Exp -> minus Exp
Exp -> plus Exp
Exp -> tilde Exp
Exp -> Exp asterisk Exp
Exp -> Exp slash Exp
Exp -> Exp slashslash Exp
Exp -> Exp percent Exp
Exp -> Exp plus Exp
Exp -> Exp minus Exp
Exp -> Exp dotdot Exp
Exp -> Exp lessless Exp
Exp -> Exp greatergreater Exp
Exp -> Exp ampersand Exp
Exp -> Exp tilde Exp
Exp -> Exp pipe Exp
Exp -> Exp less Exp
Exp -> Exp lessequal Exp
Exp -> Exp greater Exp
Exp -> Exp greaterequal Exp
Exp -> Exp tildeequal Exp
Exp -> Exp equalequal Exp
Exp -> Exp and_ Exp
Exp -> Exp or_ Exp
Exp -> Exp caret Exp
TableConstructor -> lbrace FieldList rbrace
FieldList1 -> FieldList1 FieldSep Field
FieldList1 -> Field
FieldList -> FieldList1 FieldSep?
FieldList ->
Field -> lbracket Exp rbracket equal Exp
Field -> ident equal Exp
Field -> Exp
FieldSep -> comma
FieldSep -> semicolon
FunctionDef -> function_ FuncBody
FuncBody -> lparen ParList? rparen Block end_
FuncName1 -> FuncName1 dot ident
FuncName1 -> ident
FuncName -> FuncName1 colon ident
FuncName -> FuncName1
ParList -> NameList (comma, dotdotdot)?
ParList -> dotdotdot
Statement+ -> Statement
Statement+ -> Statement+ Statement
Statement* -> Statement+
Statement* ->
ReturnStatement? -> ReturnStatement
ReturnStatement? ->
ElseIf+ -> ElseIf
ElseIf+ -> ElseIf+ ElseIf
ElseIf* -> ElseIf+
ElseIf* ->
(else_, Block) -> else_ Block
(else_, Block)? -> (else_, Block)
(else_, Block)? ->
(comma, Exp) -> comma Exp
(comma, Exp)? -> (comma, Exp)
(comma, Exp)? ->
(equal, ExpList1) -> equal ExpList1
(equal, ExpList1)? -> (equal, ExpList1)
(equal, ExpList1)? ->
semicolon? -> semicolon
semicolon? ->
FieldSep? -> FieldSep
FieldSep? ->
ParList? -> ParList
ParList? ->
(comma, dotdotdot) -> comma dotdotdot
(comma, dotdotdot)? -> (comma, dotdotdot)
(comma, dotdotdot)? ->
Augmented -> ChunkOrExpressions eof

*/
// =============================Generated Codes Begin==============================
#[doc = r" type alias for `Context`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsContext = ::rusty_lr::glr::Context<ChunkOrExpressionsTokenData>;
#[doc = r" type alias for CFG production rule"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsRule =
    ::rusty_lr::ProductionRule<&'static str, ChunkOrExpressionsNonTerminals>;
#[doc = r" type alias for DFA state"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsState = ::rusty_lr::glr::SparseState<ChunkOrExpressionsNonTerminals>;
#[doc = r" type alias for `InvalidTerminalError`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsInvalidTerminalError =
    ::rusty_lr::glr::InvalidTerminalError<Token, ChunkOrExpressionsNonTerminals, ParseError>;
#[doc = r" type alias for `MultiplePathError`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsMultiplePathError =
    ::rusty_lr::glr::MultiplePathError<Token, ChunkOrExpressionsNonTerminals>;
#[doc = r" An enum that represents non-terminal symbols"]
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std :: hash :: Hash,
    std :: cmp :: PartialEq,
    std :: cmp :: Eq,
    std :: cmp :: PartialOrd,
    std :: cmp :: Ord,
)]
pub enum ChunkOrExpressionsNonTerminals {
    ChunkOrExpressions,
    Chunk,
    Block,
    Statement,
    ElseIf,
    ReturnStatement,
    Var,
    PrefixExp,
    FunctionCall,
    Args,
    VarList,
    ExpList1,
    ExpList0,
    NameList,
    AttName,
    AttNameList,
    Attrib,
    Exp,
    TableConstructor,
    FieldList1,
    FieldList,
    Field,
    FieldSep,
    FunctionDef,
    FuncBody,
    FuncName1,
    FuncName,
    ParList,
    error,
    _StatementPlus29,
    _StatementStar30,
    _ReturnStatementQuestion31,
    _ElseIfPlus32,
    _ElseIfStar33,
    _Group34,
    __Group34Question35,
    _Group36,
    __Group36Question37,
    _Group38,
    __Group38Question39,
    _semicolonQuestion40,
    _FieldSepQuestion41,
    _ParListQuestion42,
    _Group43,
    __Group43Question44,
    Augmented,
}
impl std::fmt::Display for ChunkOrExpressionsNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use rusty_lr::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for ChunkOrExpressionsNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use rusty_lr::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl ::rusty_lr::NonTerminal for ChunkOrExpressionsNonTerminals {
    fn as_str(&self) -> &'static str {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => "ChunkOrExpressions",
            ChunkOrExpressionsNonTerminals::Chunk => "Chunk",
            ChunkOrExpressionsNonTerminals::Block => "Block",
            ChunkOrExpressionsNonTerminals::Statement => "Statement",
            ChunkOrExpressionsNonTerminals::ElseIf => "ElseIf",
            ChunkOrExpressionsNonTerminals::ReturnStatement => "ReturnStatement",
            ChunkOrExpressionsNonTerminals::Var => "Var",
            ChunkOrExpressionsNonTerminals::PrefixExp => "PrefixExp",
            ChunkOrExpressionsNonTerminals::FunctionCall => "FunctionCall",
            ChunkOrExpressionsNonTerminals::Args => "Args",
            ChunkOrExpressionsNonTerminals::VarList => "VarList",
            ChunkOrExpressionsNonTerminals::ExpList1 => "ExpList1",
            ChunkOrExpressionsNonTerminals::ExpList0 => "ExpList0",
            ChunkOrExpressionsNonTerminals::NameList => "NameList",
            ChunkOrExpressionsNonTerminals::AttName => "AttName",
            ChunkOrExpressionsNonTerminals::AttNameList => "AttNameList",
            ChunkOrExpressionsNonTerminals::Attrib => "Attrib",
            ChunkOrExpressionsNonTerminals::Exp => "Exp",
            ChunkOrExpressionsNonTerminals::TableConstructor => "TableConstructor",
            ChunkOrExpressionsNonTerminals::FieldList1 => "FieldList1",
            ChunkOrExpressionsNonTerminals::FieldList => "FieldList",
            ChunkOrExpressionsNonTerminals::Field => "Field",
            ChunkOrExpressionsNonTerminals::FieldSep => "FieldSep",
            ChunkOrExpressionsNonTerminals::FunctionDef => "FunctionDef",
            ChunkOrExpressionsNonTerminals::FuncBody => "FuncBody",
            ChunkOrExpressionsNonTerminals::FuncName1 => "FuncName1",
            ChunkOrExpressionsNonTerminals::FuncName => "FuncName",
            ChunkOrExpressionsNonTerminals::ParList => "ParList",
            ChunkOrExpressionsNonTerminals::error => "'error'",
            ChunkOrExpressionsNonTerminals::_StatementPlus29 => "Statement+",
            ChunkOrExpressionsNonTerminals::_StatementStar30 => "Statement*",
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion31 => "ReturnStatement?",
            ChunkOrExpressionsNonTerminals::_ElseIfPlus32 => "ElseIf+",
            ChunkOrExpressionsNonTerminals::_ElseIfStar33 => "ElseIf*",
            ChunkOrExpressionsNonTerminals::_Group34 => "(else_, Block)",
            ChunkOrExpressionsNonTerminals::__Group34Question35 => "(else_, Block)?",
            ChunkOrExpressionsNonTerminals::_Group36 => "(comma, Exp)",
            ChunkOrExpressionsNonTerminals::__Group36Question37 => "(comma, Exp)?",
            ChunkOrExpressionsNonTerminals::_Group38 => "(equal, ExpList1)",
            ChunkOrExpressionsNonTerminals::__Group38Question39 => "(equal, ExpList1)?",
            ChunkOrExpressionsNonTerminals::_semicolonQuestion40 => "semicolon?",
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion41 => "FieldSep?",
            ChunkOrExpressionsNonTerminals::_ParListQuestion42 => "ParList?",
            ChunkOrExpressionsNonTerminals::_Group43 => "(comma, dotdotdot)",
            ChunkOrExpressionsNonTerminals::__Group43Question44 => "(comma, dotdotdot)?",
            ChunkOrExpressionsNonTerminals::Augmented => "Augmented",
        }
    }
    fn is_trace(&self) -> bool {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => false,
            ChunkOrExpressionsNonTerminals::Chunk => false,
            ChunkOrExpressionsNonTerminals::Block => false,
            ChunkOrExpressionsNonTerminals::Statement => false,
            ChunkOrExpressionsNonTerminals::ElseIf => false,
            ChunkOrExpressionsNonTerminals::ReturnStatement => false,
            ChunkOrExpressionsNonTerminals::Var => false,
            ChunkOrExpressionsNonTerminals::PrefixExp => false,
            ChunkOrExpressionsNonTerminals::FunctionCall => false,
            ChunkOrExpressionsNonTerminals::Args => false,
            ChunkOrExpressionsNonTerminals::VarList => false,
            ChunkOrExpressionsNonTerminals::ExpList1 => false,
            ChunkOrExpressionsNonTerminals::ExpList0 => false,
            ChunkOrExpressionsNonTerminals::NameList => false,
            ChunkOrExpressionsNonTerminals::AttName => false,
            ChunkOrExpressionsNonTerminals::AttNameList => false,
            ChunkOrExpressionsNonTerminals::Attrib => false,
            ChunkOrExpressionsNonTerminals::Exp => false,
            ChunkOrExpressionsNonTerminals::TableConstructor => false,
            ChunkOrExpressionsNonTerminals::FieldList1 => false,
            ChunkOrExpressionsNonTerminals::FieldList => false,
            ChunkOrExpressionsNonTerminals::Field => false,
            ChunkOrExpressionsNonTerminals::FieldSep => false,
            ChunkOrExpressionsNonTerminals::FunctionDef => false,
            ChunkOrExpressionsNonTerminals::FuncBody => false,
            ChunkOrExpressionsNonTerminals::FuncName1 => false,
            ChunkOrExpressionsNonTerminals::FuncName => false,
            ChunkOrExpressionsNonTerminals::ParList => false,
            ChunkOrExpressionsNonTerminals::error => false,
            ChunkOrExpressionsNonTerminals::_StatementPlus29 => false,
            ChunkOrExpressionsNonTerminals::_StatementStar30 => false,
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion31 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfPlus32 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfStar33 => false,
            ChunkOrExpressionsNonTerminals::_Group34 => false,
            ChunkOrExpressionsNonTerminals::__Group34Question35 => false,
            ChunkOrExpressionsNonTerminals::_Group36 => false,
            ChunkOrExpressionsNonTerminals::__Group36Question37 => false,
            ChunkOrExpressionsNonTerminals::_Group38 => false,
            ChunkOrExpressionsNonTerminals::__Group38Question39 => false,
            ChunkOrExpressionsNonTerminals::_semicolonQuestion40 => false,
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion41 => false,
            ChunkOrExpressionsNonTerminals::_ParListQuestion42 => false,
            ChunkOrExpressionsNonTerminals::_Group43 => false,
            ChunkOrExpressionsNonTerminals::__Group43Question44 => false,
            ChunkOrExpressionsNonTerminals::Augmented => false,
        }
    }
    fn nonterm_type(&self) -> Option<::rusty_lr::NonTerminalType> {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => None,
            ChunkOrExpressionsNonTerminals::Chunk => None,
            ChunkOrExpressionsNonTerminals::Block => None,
            ChunkOrExpressionsNonTerminals::Statement => None,
            ChunkOrExpressionsNonTerminals::ElseIf => None,
            ChunkOrExpressionsNonTerminals::ReturnStatement => None,
            ChunkOrExpressionsNonTerminals::Var => None,
            ChunkOrExpressionsNonTerminals::PrefixExp => None,
            ChunkOrExpressionsNonTerminals::FunctionCall => None,
            ChunkOrExpressionsNonTerminals::Args => None,
            ChunkOrExpressionsNonTerminals::VarList => None,
            ChunkOrExpressionsNonTerminals::ExpList1 => None,
            ChunkOrExpressionsNonTerminals::ExpList0 => None,
            ChunkOrExpressionsNonTerminals::NameList => None,
            ChunkOrExpressionsNonTerminals::AttName => None,
            ChunkOrExpressionsNonTerminals::AttNameList => None,
            ChunkOrExpressionsNonTerminals::Attrib => None,
            ChunkOrExpressionsNonTerminals::Exp => None,
            ChunkOrExpressionsNonTerminals::TableConstructor => None,
            ChunkOrExpressionsNonTerminals::FieldList1 => None,
            ChunkOrExpressionsNonTerminals::FieldList => None,
            ChunkOrExpressionsNonTerminals::Field => None,
            ChunkOrExpressionsNonTerminals::FieldSep => None,
            ChunkOrExpressionsNonTerminals::FunctionDef => None,
            ChunkOrExpressionsNonTerminals::FuncBody => None,
            ChunkOrExpressionsNonTerminals::FuncName1 => None,
            ChunkOrExpressionsNonTerminals::FuncName => None,
            ChunkOrExpressionsNonTerminals::ParList => None,
            ChunkOrExpressionsNonTerminals::error => Some(::rusty_lr::NonTerminalType::Error),
            ChunkOrExpressionsNonTerminals::_StatementPlus29 => {
                Some(::rusty_lr::NonTerminalType::PlusLeft)
            }
            ChunkOrExpressionsNonTerminals::_StatementStar30 => {
                Some(::rusty_lr::NonTerminalType::Star)
            }
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion31 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_ElseIfPlus32 => {
                Some(::rusty_lr::NonTerminalType::PlusLeft)
            }
            ChunkOrExpressionsNonTerminals::_ElseIfStar33 => {
                Some(::rusty_lr::NonTerminalType::Star)
            }
            ChunkOrExpressionsNonTerminals::_Group34 => Some(::rusty_lr::NonTerminalType::Group),
            ChunkOrExpressionsNonTerminals::__Group34Question35 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_Group36 => Some(::rusty_lr::NonTerminalType::Group),
            ChunkOrExpressionsNonTerminals::__Group36Question37 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_Group38 => Some(::rusty_lr::NonTerminalType::Group),
            ChunkOrExpressionsNonTerminals::__Group38Question39 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_semicolonQuestion40 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion41 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_ParListQuestion42 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_Group43 => Some(::rusty_lr::NonTerminalType::Group),
            ChunkOrExpressionsNonTerminals::__Group43Question44 => {
                Some(::rusty_lr::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::Augmented => {
                Some(::rusty_lr::NonTerminalType::Augmented)
            }
        }
    }
}
#[doc = r" enum for each non-terminal and terminal symbol, that actually hold data"]
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone)]
pub enum ChunkOrExpressionsTokenData {
    Terminals(Token),
    Empty,
    Variant2(ChunkOrExpressions),
    Variant3(statement::Block),
    Variant4(Statement),
    Variant5(statement::StmtElseIf),
    Variant6(statement::ReturnStatement),
    Variant7(Expression),
    Variant8(expression::ExprFunctionCall),
    Variant9(expression::FunctionCallArguments),
    Variant10(Vec<Expression>),
    Variant11(Vec<SpannedString>),
    Variant12(statement::AttName),
    Variant13(Vec<statement::AttName>),
    Variant14(Option<statement::Attrib>),
    Variant15(expression::ExprTable),
    Variant16(Vec<expression::TableField>),
    Variant17(expression::TableField),
    Variant18(expression::ExprFunction),
    Variant19(statement::FunctionName),
    Variant20(expression::ParameterList),
    Variant21(Vec<Statement>),
    Variant22(Option<statement::ReturnStatement>),
    Variant23(Vec<statement::StmtElseIf>),
    Variant24(Option<statement::Block>),
    Variant25(Option<Expression>),
    Variant26(Option<Vec<Expression>>),
    Variant27(Option<Token>),
    Variant28(Option<expression::ParameterList>),
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl ChunkOrExpressionsTokenData {
    #[doc = "ChunkOrExpressions-> Chunk"]
    #[inline]
    fn reduce_ChunkOrExpressions_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant3(mut Chunk) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant2({
            ChunkOrExpressions::Chunk(Chunk)
        }))
    }
    #[doc = "ChunkOrExpressions-> ExpList1"]
    #[inline]
    fn reduce_ChunkOrExpressions_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant2({
            ChunkOrExpressions::Expressions(ExpList1)
        }))
    }
    #[doc = "Chunk-> Block"]
    #[inline]
    fn reduce_Chunk_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant3(Block))
    }
    #[doc = "Block-> Statement* ReturnStatement?"]
    #[inline]
    fn reduce_Block_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant21(mut Statement) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant22(mut ReturnStatement) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant3({
            let span0 = if let Some(first) = Statement.first() {
                first.span()
            } else {
                Span::new_none()
            };
            if let Some(ret) = ReturnStatement {
                let span1 = ret.span();
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, Some(ret), span)
            } else {
                let span1 = if let Some(last) = Statement.last() {
                    last.span()
                } else {
                    Span::new_none()
                };
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, None, span)
            }
        }))
    }
    #[doc = "Statement-> semicolon"]
    #[inline]
    fn reduce_Statement_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut semicolon) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            Statement::None(statement::StmtNone::new(semicolon.span()))
        }))
    }
    #[doc = "Statement-> VarList equal ExpList1"]
    #[inline]
    fn reduce_Statement_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant10(mut VarList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut equal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = VarList
                .first()
                .unwrap()
                .span()
                .merge_ordered(&ExpList1.last().unwrap().span());
            let span_eq = equal.span();
            Statement::Assignment(statement::StmtAssignment::new(
                VarList, ExpList1, span, span_eq,
            ))
        }))
    }
    #[doc = "Statement-> FunctionCall"]
    #[inline]
    fn reduce_Statement_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant8(mut FunctionCall) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            Statement::FunctionCall(FunctionCall)
        }))
    }
    #[doc = "Statement-> coloncolon ident coloncolon"]
    #[inline]
    fn reduce_Statement_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut c1) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut c2) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = c1.span().merge_ordered(&c2.span());
            Statement::Label(statement::StmtLabel::new(ident.into(), span))
        }))
    }
    #[doc = "Statement-> break_"]
    #[inline]
    fn reduce_Statement_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut break_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            Statement::Break(statement::StmtBreak::new(break_.span()))
        }))
    }
    #[doc = "Statement-> goto_ ident"]
    #[inline]
    fn reduce_Statement_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut goto_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = goto_.span().merge_ordered(&ident.span());
            Statement::Goto(statement::StmtGoto::new(ident.into(), span))
        }))
    }
    #[doc = "Statement-> do_ Block end_"]
    #[inline]
    fn reduce_Statement_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut do_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = do_.span().merge_ordered(&end_.span());
            Statement::Do(statement::StmtDo::new(Block, span))
        }))
    }
    #[doc = "Statement-> while_ Exp do_ Block end_"]
    #[inline]
    fn reduce_Statement_7(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut while_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = while_.span().merge_ordered(&end_.span());
            Statement::While(statement::StmtWhile::new(Exp, Block, span))
        }))
    }
    #[doc = "Statement-> repeat_ Block until_ Exp"]
    #[inline]
    fn reduce_Statement_8(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut repeat_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = repeat_.span().merge_ordered(&Exp.span());
            Statement::Repeat(statement::StmtRepeat::new(Block, Exp, span))
        }))
    }
    #[doc = "Statement-> if_ Exp then_ Block ElseIf* (else_, Block)? end_"]
    #[inline]
    fn reduce_Statement_9(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut if_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant23(mut elseifs) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant24(mut else_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = if_.span().merge_ordered(&end_.span());
            Statement::If(statement::StmtIf::new(Exp, Block, elseifs, else_, span))
        }))
    }
    #[doc = "Statement-> for_ ident equal Exp comma Exp (comma, Exp)? do_ Block end_"]
    #[inline]
    fn reduce_Statement_10(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut for_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut start) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut end) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant25(mut step) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = for_.span().merge_ordered(&end_.span());
            Statement::For(statement::StmtFor::new(
                ident.token_type.into_ident().unwrap(),
                start,
                end,
                step.unwrap_or_else(|| {
                    Expression::Numeric(expression::ExprNumeric::new(1.into(), Span::new_none()))
                }),
                Block,
                span,
            ))
        }))
    }
    #[doc = "Statement-> for_ NameList in_ ExpList1 do_ Block end_"]
    #[inline]
    fn reduce_Statement_11(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut for_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant11(mut NameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = for_.span().merge_ordered(&end_.span());
            Statement::ForGeneric(statement::StmtForGeneric::new(
                NameList, ExpList1, Block, span,
            ))
        }))
    }
    #[doc = "Statement-> function_ FuncName FuncBody"]
    #[inline]
    fn reduce_Statement_12(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut function_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant19(mut FuncName) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant18(mut FuncBody) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = function_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinition(statement::StmtFunctionDefinition::new(
                FuncName, FuncBody, span,
            ))
        }))
    }
    #[doc = "Statement-> local_ function_ ident FuncBody"]
    #[inline]
    fn reduce_Statement_13(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut local_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant18(mut FuncBody) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span = local_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinitionLocal(statement::StmtFunctionDefinitionLocal::new(
                ident.into(),
                FuncBody,
                span,
            ))
        }))
    }
    #[doc = "Statement-> local_ AttNameList (equal, ExpList1)?"]
    #[inline]
    fn reduce_Statement_14(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut local_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant13(mut AttNameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant26(mut rhs_list) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant4({
            let span0 = local_.span();
            if let Some(rhs) = rhs_list {
                let span = span0.merge_ordered(&rhs.last().unwrap().span());
                Statement::LocalDeclaration(statement::StmtLocalDeclaration::new(
                    AttNameList,
                    Some(rhs),
                    span,
                ))
            } else {
                let span = AttNameList.last().unwrap().span();
                Statement::LocalDeclaration(statement::StmtLocalDeclaration::new(
                    AttNameList,
                    None,
                    span,
                ))
            }
        }))
    }
    #[doc = "ElseIf-> elseif_ Exp then_ Block"]
    #[inline]
    fn reduce_ElseIf_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut elseif_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut then_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant5({
            let span = if Block.span().is_none() {
                elseif_.span().merge_ordered(&then_.span())
            } else {
                elseif_.span().merge_ordered(&Block.span())
            };
            statement::StmtElseIf::new(Exp, Block, span)
        }))
    }
    #[doc = "ReturnStatement-> return_ ExpList0 semicolon?"]
    #[inline]
    fn reduce_ReturnStatement_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut return_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant10(mut ExpList0) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant27(mut semicolon) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant6({
            let span0 = return_.span();
            let span = if let Some(last) = semicolon {
                span0.merge_ordered(&last.span())
            } else {
                if let Some(last) = ExpList0.last() {
                    span0.merge_ordered(&last.span())
                } else {
                    span0
                }
            };
            statement::ReturnStatement::new(ExpList0, span)
        }))
    }
    #[doc = "Var-> ident"]
    #[inline]
    fn reduce_Var_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::Ident(ident.into())
        }))
    }
    #[doc = "Var-> PrefixExp lbracket Exp rbracket"]
    #[inline]
    fn reduce_Var_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut rbracket) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            let span = PrefixExp.span().merge_ordered(&rbracket.span());
            Expression::TableIndex(expression::ExprTableIndex::new(PrefixExp, Exp, span))
        }))
    }
    #[doc = "Var-> PrefixExp dot ident"]
    #[inline]
    fn reduce_Var_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            let span = PrefixExp.span().merge_ordered(&ident.span());
            let member = expression::ExprString::from(ident);
            Expression::TableIndex(expression::ExprTableIndex::new(
                PrefixExp,
                Expression::String(member),
                span,
            ))
        }))
    }
    #[doc = "PrefixExp-> Var"]
    #[inline]
    fn reduce_PrefixExp_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut Var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7(Var))
    }
    #[doc = "PrefixExp-> FunctionCall"]
    #[inline]
    fn reduce_PrefixExp_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant8(mut FunctionCall) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::FunctionCall(FunctionCall)
        }))
    }
    #[doc = "PrefixExp-> lparen Exp rparen"]
    #[inline]
    fn reduce_PrefixExp_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkOrExpressionsTokenData::Variant7(Exp))
    }
    #[doc = "FunctionCall-> PrefixExp Args"]
    #[inline]
    fn reduce_FunctionCall_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant9(mut Args) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant8({
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, None, Args, span)
        }))
    }
    #[doc = "FunctionCall-> PrefixExp colon ident Args"]
    #[inline]
    fn reduce_FunctionCall_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant9(mut Args) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant8({
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, Some(ident.into()), Args, span)
        }))
    }
    #[doc = "Args-> lparen ExpList0 rparen"]
    #[inline]
    fn reduce_Args_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut lparen) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant10(mut ExpList0) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut rparen) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant9({
            let span = lparen.span().merge_ordered(&rparen.span());
            expression::FunctionCallArguments::new(ExpList0, span)
        }))
    }
    #[doc = "Args-> TableConstructor"]
    #[inline]
    fn reduce_Args_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant15(mut TableConstructor) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant9({
            let span = TableConstructor.span();
            let table_expr = Expression::Table(TableConstructor);
            let exprs = vec![table_expr];
            expression::FunctionCallArguments::new(exprs, span)
        }))
    }
    #[doc = "Args-> string_literal"]
    #[inline]
    fn reduce_Args_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut string_literal) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant9({
            let span = string_literal.span();
            let exprs = vec![Expression::String(string_literal.into())];
            expression::FunctionCallArguments::new(exprs, span)
        }))
    }
    #[doc = "VarList-> VarList comma Var"]
    #[inline]
    fn reduce_VarList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant10(mut VarList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut comma) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant10({
            VarList.push(Var);
            VarList
        }))
    }
    #[doc = "VarList-> Var"]
    #[inline]
    fn reduce_VarList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut Var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant10({ vec![Var] }))
    }
    #[doc = "ExpList1-> ExpList1 comma Exp"]
    #[inline]
    fn reduce_ExpList1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut comma) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant10({
            ExpList1.push(Exp);
            ExpList1
        }))
    }
    #[doc = "ExpList1-> Exp"]
    #[inline]
    fn reduce_ExpList1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant10({ vec![Exp] }))
    }
    #[doc = "ExpList0-> ExpList1"]
    #[inline]
    fn reduce_ExpList0_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant10({ ExpList1 }))
    }
    #[doc = "ExpList0-> "]
    #[inline]
    fn reduce_ExpList0_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant10({ vec![] }))
    }
    #[doc = "NameList-> NameList comma ident"]
    #[inline]
    fn reduce_NameList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant11(mut NameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant11({
            NameList.push(ident.into());
            NameList
        }))
    }
    #[doc = "NameList-> ident"]
    #[inline]
    fn reduce_NameList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant11({
            vec![ident.into()]
        }))
    }
    #[doc = "AttName-> ident Attrib"]
    #[inline]
    fn reduce_AttName_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant14(mut Attrib) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant12({
            let span = ident.span();
            statement::AttName::new(ident.into(), Attrib, span)
        }))
    }
    #[doc = "AttNameList-> AttNameList comma AttName"]
    #[inline]
    fn reduce_AttNameList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant13(mut AttNameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant12(mut AttName) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant13({
            AttNameList.push(AttName);
            AttNameList
        }))
    }
    #[doc = "AttNameList-> AttName"]
    #[inline]
    fn reduce_AttNameList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant12(mut AttName) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant13({ vec![AttName] }))
    }
    #[doc = "Attrib-> less ident greater"]
    #[inline]
    fn reduce_Attrib_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkOrExpressionsTokenData::Variant14({
            let s: SpannedString = ident.into();
            match s.as_str() {
                "const" => Some(statement::Attrib::Const),
                "close" => Some(statement::Attrib::Close),
                _ => {
                    return Err(ParseError::UnknownAttribute(s));
                }
            }
        }))
    }
    #[doc = "Attrib-> "]
    #[inline]
    fn reduce_Attrib_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant14({ None }))
    }
    #[doc = "Exp-> numeric_literal"]
    #[inline]
    fn reduce_Exp_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut numeric_literal) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::Numeric(numeric_literal.into())
        }))
    }
    #[doc = "Exp-> nil"]
    #[inline]
    fn reduce_Exp_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut nil) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::Nil(nil.into())
        }))
    }
    #[doc = "Exp-> string_literal"]
    #[inline]
    fn reduce_Exp_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut string_literal) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::String(string_literal.into())
        }))
    }
    #[doc = "Exp-> bool_"]
    #[inline]
    fn reduce_Exp_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut bool_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::Bool(bool_.into())
        }))
    }
    #[doc = "Exp-> dotdotdot"]
    #[inline]
    fn reduce_Exp_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut dotdotdot) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::Variadic(dotdotdot.into())
        }))
    }
    #[doc = "Exp-> FunctionDef"]
    #[inline]
    fn reduce_Exp_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant18(mut FunctionDef) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::Function(FunctionDef)
        }))
    }
    #[doc = "Exp-> PrefixExp"]
    #[inline]
    fn reduce_Exp_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7(PrefixExp))
    }
    #[doc = "Exp-> TableConstructor"]
    #[inline]
    fn reduce_Exp_7(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant15(mut TableConstructor) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            Expression::Table(TableConstructor)
        }))
    }
    #[doc = "Exp-> not_ Exp"]
    #[inline]
    fn reduce_Exp_8(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut not_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_unary_node!(LogicalNot, not_, Exp)
        }))
    }
    #[doc = "Exp-> hash Exp"]
    #[inline]
    fn reduce_Exp_9(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut hash) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_unary_node!(Length, hash, Exp)
        }))
    }
    #[doc = "Exp-> minus Exp"]
    #[inline]
    fn reduce_Exp_10(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut minus) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_unary_node!(Minus, minus, Exp)
        }))
    }
    #[doc = "Exp-> plus Exp"]
    #[inline]
    fn reduce_Exp_11(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut plus) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_unary_node!(Plus, plus, Exp)
        }))
    }
    #[doc = "Exp-> tilde Exp"]
    #[inline]
    fn reduce_Exp_12(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut tilde) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_unary_node!(BitwiseNot, tilde, Exp)
        }))
    }
    #[doc = "Exp-> Exp asterisk Exp"]
    #[inline]
    fn reduce_Exp_13(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut asterisk) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Mul, asterisk, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp slash Exp"]
    #[inline]
    fn reduce_Exp_14(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut slash) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Div, slash, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp slashslash Exp"]
    #[inline]
    fn reduce_Exp_15(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut slashslash) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(FloorDiv, slashslash, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp percent Exp"]
    #[inline]
    fn reduce_Exp_16(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut percent) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Mod, percent, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp plus Exp"]
    #[inline]
    fn reduce_Exp_17(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut plus) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Add, plus, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp minus Exp"]
    #[inline]
    fn reduce_Exp_18(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut minus) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Sub, minus, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp dotdot Exp"]
    #[inline]
    fn reduce_Exp_19(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut dotdot) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Concat, dotdot, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp lessless Exp"]
    #[inline]
    fn reduce_Exp_20(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut lessless) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(ShiftLeft, lessless, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp greatergreater Exp"]
    #[inline]
    fn reduce_Exp_21(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut greatergreater) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(ShiftRight, greatergreater, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp ampersand Exp"]
    #[inline]
    fn reduce_Exp_22(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut ampersand) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(BitwiseAnd, ampersand, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp tilde Exp"]
    #[inline]
    fn reduce_Exp_23(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut tilde) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(BitwiseXor, tilde, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp pipe Exp"]
    #[inline]
    fn reduce_Exp_24(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut pipe) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(BitwiseOr, pipe, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp less Exp"]
    #[inline]
    fn reduce_Exp_25(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut less) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(LessThan, less, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp lessequal Exp"]
    #[inline]
    fn reduce_Exp_26(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut lessequal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(LessEqual, lessequal, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp greater Exp"]
    #[inline]
    fn reduce_Exp_27(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut greater) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(GreaterThan, greater, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp greaterequal Exp"]
    #[inline]
    fn reduce_Exp_28(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut greaterequal) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(GreaterEqual, greaterequal, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp tildeequal Exp"]
    #[inline]
    fn reduce_Exp_29(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut tildeequal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(NotEqual, tildeequal, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp equalequal Exp"]
    #[inline]
    fn reduce_Exp_30(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut equalequal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Equal, equalequal, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp and_ Exp"]
    #[inline]
    fn reduce_Exp_31(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut and_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(LogicalAnd, and_, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp or_ Exp"]
    #[inline]
    fn reduce_Exp_32(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut or_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(LogicalOr, or_, lhs, rhs)
        }))
    }
    #[doc = "Exp-> Exp caret Exp"]
    #[inline]
    fn reduce_Exp_33(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut caret) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7({
            new_binary_node!(Pow, caret, lhs, rhs)
        }))
    }
    #[doc = "TableConstructor-> lbrace FieldList rbrace"]
    #[inline]
    fn reduce_TableConstructor_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut lbrace) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant16(mut FieldList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut rbrace) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant15({
            let span = lbrace.span().merge_ordered(&rbrace.span());
            expression::ExprTable::new(FieldList, span)
        }))
    }
    #[doc = "FieldList1-> FieldList1 FieldSep Field"]
    #[inline]
    fn reduce_FieldList1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant16(mut FieldList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant17(mut Field) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant16({
            FieldList1.push(Field);
            FieldList1
        }))
    }
    #[doc = "FieldList1-> Field"]
    #[inline]
    fn reduce_FieldList1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant17(mut Field) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant16({ vec![Field] }))
    }
    #[doc = "FieldList-> FieldList1 FieldSep?"]
    #[inline]
    fn reduce_FieldList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant16(mut FieldList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkOrExpressionsTokenData::Variant16({ FieldList1 }))
    }
    #[doc = "FieldList-> "]
    #[inline]
    fn reduce_FieldList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant16({ vec![] }))
    }
    #[doc = "Field-> lbracket Exp rbracket equal Exp"]
    #[inline]
    fn reduce_Field_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut lbracket) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant7(mut k) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut v) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant17({
            let span = lbracket.span().merge_ordered(&v.span());
            expression::TableField::KeyValue(expression::TableFieldKeyValue::new(k, v, span))
        }))
    }
    #[doc = "Field-> ident equal Exp"]
    #[inline]
    fn reduce_Field_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant17({
            let span = ident.span().merge_ordered(&Exp.span());
            expression::TableField::NameValue(expression::TableFieldNameValue::new(
                ident.into(),
                Exp,
                span,
            ))
        }))
    }
    #[doc = "Field-> Exp"]
    #[inline]
    fn reduce_Field_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant17({
            expression::TableField::Value(expression::TableFieldValue::new(Exp))
        }))
    }
    #[doc = "FieldSep-> comma"]
    #[inline]
    fn reduce_FieldSep_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsTokenData::Empty)
    }
    #[doc = "FieldSep-> semicolon"]
    #[inline]
    fn reduce_FieldSep_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsTokenData::Empty)
    }
    #[doc = "FunctionDef-> function_ FuncBody"]
    #[inline]
    fn reduce_FunctionDef_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut function_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant18(mut FuncBody) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant18({
            let span = function_.span().merge_ordered(&FuncBody.span());
            FuncBody.span = span;
            FuncBody
        }))
    }
    #[doc = "FuncBody-> lparen ParList? rparen Block end_"]
    #[inline]
    fn reduce_FuncBody_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut lparen) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant28(mut ParList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant18({
            let span = lparen.span().merge_ordered(&end_.span());
            expression::ExprFunction::new(ParList, Block, span)
        }))
    }
    #[doc = "FuncName1-> FuncName1 dot ident"]
    #[inline]
    fn reduce_FuncName1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant11(mut FuncName1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut dot) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant11({
            FuncName1.push(ident.into());
            FuncName1
        }))
    }
    #[doc = "FuncName1-> ident"]
    #[inline]
    fn reduce_FuncName1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant11({
            vec![ident.into()]
        }))
    }
    #[doc = "FuncName-> FuncName1 colon ident"]
    #[inline]
    fn reduce_FuncName_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant11(mut FuncName1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Terminals(mut ident) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant19({
            let span = FuncName1
                .first()
                .unwrap()
                .span()
                .merge_ordered(&ident.span());
            statement::FunctionName::new(FuncName1, Some(ident.into()), span)
        }))
    }
    #[doc = "FuncName-> FuncName1"]
    #[inline]
    fn reduce_FuncName_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant11(mut FuncName1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant19({
            let span = FuncName1
                .first()
                .unwrap()
                .span()
                .merge_ordered(&FuncName1.last().unwrap().span());
            statement::FunctionName::new(FuncName1, None, span)
        }))
    }
    #[doc = "ParList-> NameList (comma, dotdotdot)?"]
    #[inline]
    fn reduce_ParList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant11(mut NameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant27(mut var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant20({
            if let Some(var) = var {
                let span = NameList.first().unwrap().span().merge_ordered(&var.span());
                expression::ParameterList::new(NameList, true, span)
            } else {
                let span = NameList.first().unwrap().span();
                expression::ParameterList::new(NameList, false, span)
            }
        }))
    }
    #[doc = "ParList-> dotdotdot"]
    #[inline]
    fn reduce_ParList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut dotdotdot) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant20({
            expression::ParameterList::new(Vec::new(), true, dotdotdot.span())
        }))
    }
    #[doc = "_StatementPlus29-> Statement"]
    #[inline]
    fn reduce__StatementPlus29_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant4(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant21({ vec![A] }))
    }
    #[doc = "_StatementPlus29-> Statement+ Statement"]
    #[inline]
    fn reduce__StatementPlus29_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant21(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant4(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant21({
            Ap.push(A);
            Ap
        }))
    }
    #[doc = "_StatementStar30-> Statement+"]
    #[inline]
    fn reduce__StatementStar30_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant21(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant21({ Ap }))
    }
    #[doc = "_StatementStar30-> "]
    #[inline]
    fn reduce__StatementStar30_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant21({ vec![] }))
    }
    #[doc = "_ReturnStatementQuestion31-> ReturnStatement"]
    #[inline]
    fn reduce__ReturnStatementQuestion31_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant6(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant22({ Some(A) }))
    }
    #[doc = "_ReturnStatementQuestion31-> "]
    #[inline]
    fn reduce__ReturnStatementQuestion31_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant22({ None }))
    }
    #[doc = "_ElseIfPlus32-> ElseIf"]
    #[inline]
    fn reduce__ElseIfPlus32_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant5(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant23({ vec![A] }))
    }
    #[doc = "_ElseIfPlus32-> ElseIf+ ElseIf"]
    #[inline]
    fn reduce__ElseIfPlus32_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant23(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsTokenData::Variant5(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant23({
            Ap.push(A);
            Ap
        }))
    }
    #[doc = "_ElseIfStar33-> ElseIf+"]
    #[inline]
    fn reduce__ElseIfStar33_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant23(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant23({ Ap }))
    }
    #[doc = "_ElseIfStar33-> "]
    #[inline]
    fn reduce__ElseIfStar33_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant23({ vec![] }))
    }
    #[doc = "_Group34-> else_ Block"]
    #[inline]
    fn reduce__Group34_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant3(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant3(__rustylr_group_elem1))
    }
    #[doc = "__Group34Question35-> (else_, Block)"]
    #[inline]
    fn reduce___Group34Question35_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant3(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant24({ Some(A) }))
    }
    #[doc = "__Group34Question35-> "]
    #[inline]
    fn reduce___Group34Question35_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant24({ None }))
    }
    #[doc = "_Group36-> comma Exp"]
    #[inline]
    fn reduce__Group36_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant7(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant7(__rustylr_group_elem1))
    }
    #[doc = "__Group36Question37-> (comma, Exp)"]
    #[inline]
    fn reduce___Group36Question37_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant7(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant25({ Some(A) }))
    }
    #[doc = "__Group36Question37-> "]
    #[inline]
    fn reduce___Group36Question37_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant25({ None }))
    }
    #[doc = "_Group38-> equal ExpList1"]
    #[inline]
    fn reduce__Group38_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Variant10(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant10(
            __rustylr_group_elem1,
        ))
    }
    #[doc = "__Group38Question39-> (equal, ExpList1)"]
    #[inline]
    fn reduce___Group38Question39_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant10(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant26({ Some(A) }))
    }
    #[doc = "__Group38Question39-> "]
    #[inline]
    fn reduce___Group38Question39_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant26({ None }))
    }
    #[doc = "_semicolonQuestion40-> semicolon"]
    #[inline]
    fn reduce__semicolonQuestion40_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant27({ Some(A) }))
    }
    #[doc = "_semicolonQuestion40-> "]
    #[inline]
    fn reduce__semicolonQuestion40_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant27({ None }))
    }
    #[doc = "_FieldSepQuestion41-> FieldSep"]
    #[inline]
    fn reduce__FieldSepQuestion41_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsTokenData::Empty)
    }
    #[doc = "_FieldSepQuestion41-> "]
    #[inline]
    fn reduce__FieldSepQuestion41_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsTokenData::Empty)
    }
    #[doc = "_ParListQuestion42-> ParList"]
    #[inline]
    fn reduce__ParListQuestion42_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Variant20(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant28({ Some(A) }))
    }
    #[doc = "_ParListQuestion42-> "]
    #[inline]
    fn reduce__ParListQuestion42_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant28({ None }))
    }
    #[doc = "_Group43-> comma dotdotdot"]
    #[inline]
    fn reduce__Group43_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsTokenData::Terminals(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Terminals(
            __rustylr_group_elem1,
        ))
    }
    #[doc = "__Group43Question44-> (comma, dotdotdot)"]
    #[inline]
    fn reduce___Group43Question44_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        let ChunkOrExpressionsTokenData::Terminals(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsTokenData::Variant27({ Some(A) }))
    }
    #[doc = "__Group43Question44-> "]
    #[inline]
    fn reduce___Group43Question44_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        Ok(ChunkOrExpressionsTokenData::Variant27({ None }))
    }
    #[doc = "Augmented-> ChunkOrExpressions eof"]
    #[inline]
    fn reduce_Augmented_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsTokenData, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsTokenData::Empty)
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr::TokenData for ChunkOrExpressionsTokenData {
    type Term = Token;
    type NonTerm = ChunkOrExpressionsNonTerminals;
    type ReduceActionError = ParseError;
    type UserData = ();
    type StartType = ChunkOrExpressions;
    fn reduce_action(
        rule_index: usize,
        reduce_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Self::Term,
        user_data: &mut Self::UserData,
    ) -> Result<Self, Self::ReduceActionError> {
        match rule_index {
            0usize => Self::reduce_ChunkOrExpressions_0(reduce_args, shift, lookahead, user_data),
            1usize => Self::reduce_ChunkOrExpressions_1(reduce_args, shift, lookahead, user_data),
            2usize => Self::reduce_Chunk_0(reduce_args, shift, lookahead, user_data),
            3usize => Self::reduce_Block_0(reduce_args, shift, lookahead, user_data),
            4usize => Self::reduce_Statement_0(reduce_args, shift, lookahead, user_data),
            5usize => Self::reduce_Statement_1(reduce_args, shift, lookahead, user_data),
            6usize => Self::reduce_Statement_2(reduce_args, shift, lookahead, user_data),
            7usize => Self::reduce_Statement_3(reduce_args, shift, lookahead, user_data),
            8usize => Self::reduce_Statement_4(reduce_args, shift, lookahead, user_data),
            9usize => Self::reduce_Statement_5(reduce_args, shift, lookahead, user_data),
            10usize => Self::reduce_Statement_6(reduce_args, shift, lookahead, user_data),
            11usize => Self::reduce_Statement_7(reduce_args, shift, lookahead, user_data),
            12usize => Self::reduce_Statement_8(reduce_args, shift, lookahead, user_data),
            13usize => Self::reduce_Statement_9(reduce_args, shift, lookahead, user_data),
            14usize => Self::reduce_Statement_10(reduce_args, shift, lookahead, user_data),
            15usize => Self::reduce_Statement_11(reduce_args, shift, lookahead, user_data),
            16usize => Self::reduce_Statement_12(reduce_args, shift, lookahead, user_data),
            17usize => Self::reduce_Statement_13(reduce_args, shift, lookahead, user_data),
            18usize => Self::reduce_Statement_14(reduce_args, shift, lookahead, user_data),
            19usize => Self::reduce_ElseIf_0(reduce_args, shift, lookahead, user_data),
            20usize => Self::reduce_ReturnStatement_0(reduce_args, shift, lookahead, user_data),
            21usize => Self::reduce_Var_0(reduce_args, shift, lookahead, user_data),
            22usize => Self::reduce_Var_1(reduce_args, shift, lookahead, user_data),
            23usize => Self::reduce_Var_2(reduce_args, shift, lookahead, user_data),
            24usize => Self::reduce_PrefixExp_0(reduce_args, shift, lookahead, user_data),
            25usize => Self::reduce_PrefixExp_1(reduce_args, shift, lookahead, user_data),
            26usize => Self::reduce_PrefixExp_2(reduce_args, shift, lookahead, user_data),
            27usize => Self::reduce_FunctionCall_0(reduce_args, shift, lookahead, user_data),
            28usize => Self::reduce_FunctionCall_1(reduce_args, shift, lookahead, user_data),
            29usize => Self::reduce_Args_0(reduce_args, shift, lookahead, user_data),
            30usize => Self::reduce_Args_1(reduce_args, shift, lookahead, user_data),
            31usize => Self::reduce_Args_2(reduce_args, shift, lookahead, user_data),
            32usize => Self::reduce_VarList_0(reduce_args, shift, lookahead, user_data),
            33usize => Self::reduce_VarList_1(reduce_args, shift, lookahead, user_data),
            34usize => Self::reduce_ExpList1_0(reduce_args, shift, lookahead, user_data),
            35usize => Self::reduce_ExpList1_1(reduce_args, shift, lookahead, user_data),
            36usize => Self::reduce_ExpList0_0(reduce_args, shift, lookahead, user_data),
            37usize => Self::reduce_ExpList0_1(reduce_args, shift, lookahead, user_data),
            38usize => Self::reduce_NameList_0(reduce_args, shift, lookahead, user_data),
            39usize => Self::reduce_NameList_1(reduce_args, shift, lookahead, user_data),
            40usize => Self::reduce_AttName_0(reduce_args, shift, lookahead, user_data),
            41usize => Self::reduce_AttNameList_0(reduce_args, shift, lookahead, user_data),
            42usize => Self::reduce_AttNameList_1(reduce_args, shift, lookahead, user_data),
            43usize => Self::reduce_Attrib_0(reduce_args, shift, lookahead, user_data),
            44usize => Self::reduce_Attrib_1(reduce_args, shift, lookahead, user_data),
            45usize => Self::reduce_Exp_0(reduce_args, shift, lookahead, user_data),
            46usize => Self::reduce_Exp_1(reduce_args, shift, lookahead, user_data),
            47usize => Self::reduce_Exp_2(reduce_args, shift, lookahead, user_data),
            48usize => Self::reduce_Exp_3(reduce_args, shift, lookahead, user_data),
            49usize => Self::reduce_Exp_4(reduce_args, shift, lookahead, user_data),
            50usize => Self::reduce_Exp_5(reduce_args, shift, lookahead, user_data),
            51usize => Self::reduce_Exp_6(reduce_args, shift, lookahead, user_data),
            52usize => Self::reduce_Exp_7(reduce_args, shift, lookahead, user_data),
            53usize => Self::reduce_Exp_8(reduce_args, shift, lookahead, user_data),
            54usize => Self::reduce_Exp_9(reduce_args, shift, lookahead, user_data),
            55usize => Self::reduce_Exp_10(reduce_args, shift, lookahead, user_data),
            56usize => Self::reduce_Exp_11(reduce_args, shift, lookahead, user_data),
            57usize => Self::reduce_Exp_12(reduce_args, shift, lookahead, user_data),
            58usize => Self::reduce_Exp_13(reduce_args, shift, lookahead, user_data),
            59usize => Self::reduce_Exp_14(reduce_args, shift, lookahead, user_data),
            60usize => Self::reduce_Exp_15(reduce_args, shift, lookahead, user_data),
            61usize => Self::reduce_Exp_16(reduce_args, shift, lookahead, user_data),
            62usize => Self::reduce_Exp_17(reduce_args, shift, lookahead, user_data),
            63usize => Self::reduce_Exp_18(reduce_args, shift, lookahead, user_data),
            64usize => Self::reduce_Exp_19(reduce_args, shift, lookahead, user_data),
            65usize => Self::reduce_Exp_20(reduce_args, shift, lookahead, user_data),
            66usize => Self::reduce_Exp_21(reduce_args, shift, lookahead, user_data),
            67usize => Self::reduce_Exp_22(reduce_args, shift, lookahead, user_data),
            68usize => Self::reduce_Exp_23(reduce_args, shift, lookahead, user_data),
            69usize => Self::reduce_Exp_24(reduce_args, shift, lookahead, user_data),
            70usize => Self::reduce_Exp_25(reduce_args, shift, lookahead, user_data),
            71usize => Self::reduce_Exp_26(reduce_args, shift, lookahead, user_data),
            72usize => Self::reduce_Exp_27(reduce_args, shift, lookahead, user_data),
            73usize => Self::reduce_Exp_28(reduce_args, shift, lookahead, user_data),
            74usize => Self::reduce_Exp_29(reduce_args, shift, lookahead, user_data),
            75usize => Self::reduce_Exp_30(reduce_args, shift, lookahead, user_data),
            76usize => Self::reduce_Exp_31(reduce_args, shift, lookahead, user_data),
            77usize => Self::reduce_Exp_32(reduce_args, shift, lookahead, user_data),
            78usize => Self::reduce_Exp_33(reduce_args, shift, lookahead, user_data),
            79usize => Self::reduce_TableConstructor_0(reduce_args, shift, lookahead, user_data),
            80usize => Self::reduce_FieldList1_0(reduce_args, shift, lookahead, user_data),
            81usize => Self::reduce_FieldList1_1(reduce_args, shift, lookahead, user_data),
            82usize => Self::reduce_FieldList_0(reduce_args, shift, lookahead, user_data),
            83usize => Self::reduce_FieldList_1(reduce_args, shift, lookahead, user_data),
            84usize => Self::reduce_Field_0(reduce_args, shift, lookahead, user_data),
            85usize => Self::reduce_Field_1(reduce_args, shift, lookahead, user_data),
            86usize => Self::reduce_Field_2(reduce_args, shift, lookahead, user_data),
            87usize => Self::reduce_FieldSep_0(reduce_args, shift, lookahead, user_data),
            88usize => Self::reduce_FieldSep_1(reduce_args, shift, lookahead, user_data),
            89usize => Self::reduce_FunctionDef_0(reduce_args, shift, lookahead, user_data),
            90usize => Self::reduce_FuncBody_0(reduce_args, shift, lookahead, user_data),
            91usize => Self::reduce_FuncName1_0(reduce_args, shift, lookahead, user_data),
            92usize => Self::reduce_FuncName1_1(reduce_args, shift, lookahead, user_data),
            93usize => Self::reduce_FuncName_0(reduce_args, shift, lookahead, user_data),
            94usize => Self::reduce_FuncName_1(reduce_args, shift, lookahead, user_data),
            95usize => Self::reduce_ParList_0(reduce_args, shift, lookahead, user_data),
            96usize => Self::reduce_ParList_1(reduce_args, shift, lookahead, user_data),
            97usize => Self::reduce__StatementPlus29_0(reduce_args, shift, lookahead, user_data),
            98usize => Self::reduce__StatementPlus29_1(reduce_args, shift, lookahead, user_data),
            99usize => Self::reduce__StatementStar30_0(reduce_args, shift, lookahead, user_data),
            100usize => Self::reduce__StatementStar30_1(reduce_args, shift, lookahead, user_data),
            101usize => {
                Self::reduce__ReturnStatementQuestion31_0(reduce_args, shift, lookahead, user_data)
            }
            102usize => {
                Self::reduce__ReturnStatementQuestion31_1(reduce_args, shift, lookahead, user_data)
            }
            103usize => Self::reduce__ElseIfPlus32_0(reduce_args, shift, lookahead, user_data),
            104usize => Self::reduce__ElseIfPlus32_1(reduce_args, shift, lookahead, user_data),
            105usize => Self::reduce__ElseIfStar33_0(reduce_args, shift, lookahead, user_data),
            106usize => Self::reduce__ElseIfStar33_1(reduce_args, shift, lookahead, user_data),
            107usize => Self::reduce__Group34_0(reduce_args, shift, lookahead, user_data),
            108usize => {
                Self::reduce___Group34Question35_0(reduce_args, shift, lookahead, user_data)
            }
            109usize => {
                Self::reduce___Group34Question35_1(reduce_args, shift, lookahead, user_data)
            }
            110usize => Self::reduce__Group36_0(reduce_args, shift, lookahead, user_data),
            111usize => {
                Self::reduce___Group36Question37_0(reduce_args, shift, lookahead, user_data)
            }
            112usize => {
                Self::reduce___Group36Question37_1(reduce_args, shift, lookahead, user_data)
            }
            113usize => Self::reduce__Group38_0(reduce_args, shift, lookahead, user_data),
            114usize => {
                Self::reduce___Group38Question39_0(reduce_args, shift, lookahead, user_data)
            }
            115usize => {
                Self::reduce___Group38Question39_1(reduce_args, shift, lookahead, user_data)
            }
            116usize => {
                Self::reduce__semicolonQuestion40_0(reduce_args, shift, lookahead, user_data)
            }
            117usize => {
                Self::reduce__semicolonQuestion40_1(reduce_args, shift, lookahead, user_data)
            }
            118usize => {
                Self::reduce__FieldSepQuestion41_0(reduce_args, shift, lookahead, user_data)
            }
            119usize => {
                Self::reduce__FieldSepQuestion41_1(reduce_args, shift, lookahead, user_data)
            }
            120usize => Self::reduce__ParListQuestion42_0(reduce_args, shift, lookahead, user_data),
            121usize => Self::reduce__ParListQuestion42_1(reduce_args, shift, lookahead, user_data),
            122usize => Self::reduce__Group43_0(reduce_args, shift, lookahead, user_data),
            123usize => {
                Self::reduce___Group43Question44_0(reduce_args, shift, lookahead, user_data)
            }
            124usize => {
                Self::reduce___Group43Question44_1(reduce_args, shift, lookahead, user_data)
            }
            125usize => Self::reduce_Augmented_0(reduce_args, shift, lookahead, user_data),
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
    fn new_error_nonterm() -> Self {
        ChunkOrExpressionsTokenData::Empty
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl From<Token> for ChunkOrExpressionsTokenData {
    fn from(token: Token) -> Self {
        ChunkOrExpressionsTokenData::Terminals(token)
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl TryFrom<ChunkOrExpressionsTokenData> for ChunkOrExpressions {
    type Error = ();
    fn try_from(token: ChunkOrExpressionsTokenData) -> Result<Self, Self::Error> {
        match token {
            ChunkOrExpressionsTokenData::Variant2(data) => Ok(data),
            _ => Err(()),
        }
    }
}
#[doc = r" A struct that holds the entire parser table and production rules."]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
pub struct ChunkOrExpressionsParser {
    #[doc = r" production rules"]
    pub rules: Vec<ChunkOrExpressionsRule>,
    #[doc = r" states"]
    pub states: Vec<ChunkOrExpressionsState>,
    #[doc = r" terminal classes"]
    pub classes: Vec<Vec<&'static str>>,
}
impl ::rusty_lr::glr::Parser for ChunkOrExpressionsParser {
    type Term = Token;
    type NonTerm = ChunkOrExpressionsNonTerminals;
    type State = ChunkOrExpressionsState;
    type TerminalClassElement = &'static str;
    fn get_rules(&self) -> &[ChunkOrExpressionsRule] {
        &self.rules
    }
    fn get_states(&self) -> &[ChunkOrExpressionsState] {
        &self.states
    }
    fn get_terminals(
        &self,
        i: usize,
    ) -> Option<impl IntoIterator<Item = Self::TerminalClassElement> + '_> {
        self.classes.get(i).map(|class| class.iter().copied())
    }
    fn to_terminal_class(&self, terminal: &Self::Term) -> usize {
        #[allow(unreachable_patterns)]
        match filter(terminal) {
            TokenType::Ident(_) => 0usize,
            TokenType::String(_) => 1usize,
            TokenType::Numeric(_) => 2usize,
            TokenType::Nil => 3usize,
            TokenType::Bool(_) => 4usize,
            TokenType::Plus => 5usize,
            TokenType::Minus => 6usize,
            TokenType::Asterisk => 7usize,
            TokenType::Slash => 8usize,
            TokenType::Percent => 9usize,
            TokenType::Caret => 10usize,
            TokenType::Hash => 11usize,
            TokenType::Ampersand => 12usize,
            TokenType::Tilde => 13usize,
            TokenType::Pipe => 14usize,
            TokenType::LessLess => 15usize,
            TokenType::GreaterGreater => 16usize,
            TokenType::SlashSlash => 17usize,
            TokenType::EqualEqual => 18usize,
            TokenType::TildeEqual => 19usize,
            TokenType::LessEqual => 20usize,
            TokenType::GreaterEqual => 21usize,
            TokenType::Less => 22usize,
            TokenType::Greater => 23usize,
            TokenType::Equal => 24usize,
            TokenType::LParen => 25usize,
            TokenType::RParen => 26usize,
            TokenType::LBrace => 27usize,
            TokenType::RBrace => 28usize,
            TokenType::LBracket => 29usize,
            TokenType::RBracket => 30usize,
            TokenType::ColonColon => 31usize,
            TokenType::Semicolon => 32usize,
            TokenType::Colon => 33usize,
            TokenType::Comma => 34usize,
            TokenType::Dot => 35usize,
            TokenType::DotDot => 36usize,
            TokenType::DotDotDot => 37usize,
            TokenType::And => 38usize,
            TokenType::Break => 39usize,
            TokenType::Do => 40usize,
            TokenType::Else => 41usize,
            TokenType::Elseif => 42usize,
            TokenType::End => 43usize,
            TokenType::For => 44usize,
            TokenType::Function => 45usize,
            TokenType::Goto => 46usize,
            TokenType::If => 47usize,
            TokenType::In => 48usize,
            TokenType::Local => 49usize,
            TokenType::Not => 50usize,
            TokenType::Or => 51usize,
            TokenType::Repeat => 52usize,
            TokenType::Return => 53usize,
            TokenType::Then => 54usize,
            TokenType::Until => 55usize,
            TokenType::While => 56usize,
            TokenType::Eof => 57usize,
            _ => 58usize,
        }
    }
    fn get_error_nonterm(&self) -> Option<Self::NonTerm> {
        None
    }
}
#[doc = r" A struct that holds the whole parser table."]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
impl ChunkOrExpressionsParser {
    #[doc = r" Calculates the states and parser tables from the grammar."]
    #[allow(clippy::clone_on_copy)]
    pub fn new() -> Self {
        let mut builder = ::rusty_lr::builder::Grammar::new();
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(22usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(14usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(36usize),
            ::rusty_lr::ReduceType::Right,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(6usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(17usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(9usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(20usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(12usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(23usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(15usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(7usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(18usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(51usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(10usize),
            ::rusty_lr::ReduceType::Right,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(21usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(13usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(5usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(16usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(38usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(8usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(19usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_precedence(::rusty_lr::builder::Operator::Term(22usize), 2usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(36usize), 7usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(14usize), 3usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(6usize), 8usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(17usize), 9usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(2usize), 11usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(9usize), 9usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(20usize), 2usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(5usize), 11usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(12usize), 5usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(23usize), 2usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(0usize), 12usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(15usize), 6usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(3usize), 11usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(18usize), 2usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(51usize), 0usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(7usize), 9usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(21usize), 2usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(10usize), 10usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(13usize), 4usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(1usize), 11usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(16usize), 6usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(38usize), 1usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(5usize), 8usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(19usize), 2usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(8usize), 9usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(4usize), 11usize);
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Chunk,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ExpList1,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Chunk,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Block,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Block,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_StatementStar30),
                ::rusty_lr::Token::NonTerm(
                    ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion31,
                ),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![::rusty_lr::Token::Term(32usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::VarList),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FunctionCall,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(31usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(31usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![::rusty_lr::Token::Term(39usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(46usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(56usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(52usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(55usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(47usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(54usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ElseIfStar33),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group34Question35),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(44usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group36Question37),
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(44usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
                ::rusty_lr::Token::Term(48usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(45usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(49usize),
                ::rusty_lr::Token::Term(45usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(49usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttNameList),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group38Question39),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ElseIf,
            vec![
                ::rusty_lr::Token::Term(42usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(54usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ReturnStatement,
            vec![
                ::rusty_lr::Token::Term(53usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList0),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_semicolonQuestion40),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Var,
            vec![::rusty_lr::Token::Term(0usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Var,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(29usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(30usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Var,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(35usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::PrefixExp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Var,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::PrefixExp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FunctionCall,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::PrefixExp,
            vec![
                ::rusty_lr::Token::Term(25usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(26usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FunctionCall,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Args),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FunctionCall,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(33usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Args),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Args,
            vec![
                ::rusty_lr::Token::Term(25usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList0),
                ::rusty_lr::Token::Term(26usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Args,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::TableConstructor,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Args,
            vec![::rusty_lr::Token::Term(1usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::VarList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::VarList),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Var),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::VarList,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Var,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList1,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList1,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Exp,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList0,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ExpList1,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList0,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::NameList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::NameList,
            vec![::rusty_lr::Token::Term(0usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::AttName,
            vec![
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Attrib),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::AttNameList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttNameList),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttName),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::AttNameList,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::AttName,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Attrib,
            vec![
                ::rusty_lr::Token::Term(22usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(23usize),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(22usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Attrib,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::Term(2usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::Term(3usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::Term(1usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::Term(4usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::Term(37usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FunctionDef,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::PrefixExp,
            )],
            None,
            Some(::rusty_lr::builder::Operator::Prec(0usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::TableConstructor,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(50usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(1usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(11usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(2usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(6usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(3usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(5usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(4usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(13usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(5usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(7usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(7usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(8usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(8usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(17usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(17usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(9usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(9usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(5usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(5usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(6usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(6usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(36usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(36usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(15usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(15usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(16usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(16usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(12usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(12usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(13usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(13usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(14usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(14usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(22usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(22usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(20usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(20usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(23usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(23usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(21usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(21usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(19usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(19usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(18usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(18usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(38usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(38usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(51usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(51usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(10usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(10usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::TableConstructor,
            vec![
                ::rusty_lr::Token::Term(27usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldList),
                ::rusty_lr::Token::Term(28usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList1,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldList1),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldSep),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Field),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList1,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Field,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldList1),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_FieldSepQuestion41),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Field,
            vec![
                ::rusty_lr::Token::Term(29usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(30usize),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Field,
            vec![
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Field,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Exp,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldSep,
            vec![::rusty_lr::Token::Term(34usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldSep,
            vec![::rusty_lr::Token::Term(32usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FunctionDef,
            vec![
                ::rusty_lr::Token::Term(45usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncBody,
            vec![
                ::rusty_lr::Token::Term(25usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ParListQuestion42),
                ::rusty_lr::Token::Term(26usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName1,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName1),
                ::rusty_lr::Token::Term(35usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName1,
            vec![::rusty_lr::Token::Term(0usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName1),
                ::rusty_lr::Token::Term(33usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FuncName1,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ParList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group43Question44),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ParList,
            vec![::rusty_lr::Token::Term(37usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementPlus29,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Statement,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementPlus29,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_StatementPlus29),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Statement),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementStar30,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_StatementPlus29,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementStar30,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion31,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ReturnStatement,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion31,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfPlus32,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ElseIf,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfPlus32,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ElseIfPlus32),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ElseIf),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfStar33,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_ElseIfPlus32,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfStar33,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group34,
            vec![
                ::rusty_lr::Token::Term(41usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group34Question35,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group34,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group34Question35,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group36,
            vec![
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group36Question37,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group36,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group36Question37,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group38,
            vec![
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group38Question39,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group38,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group38Question39,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_semicolonQuestion40,
            vec![::rusty_lr::Token::Term(32usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_semicolonQuestion40,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion41,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FieldSep,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion41,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ParListQuestion42,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ParList,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ParListQuestion42,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group43,
            vec![
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::Term(37usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group43Question44,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group43,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group43Question44,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Augmented,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ChunkOrExpressions),
                ::rusty_lr::Token::Term(57usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_empty_rule(ChunkOrExpressionsNonTerminals::error);
        let Ok(states) = builder.build_lalr(
            ChunkOrExpressionsNonTerminals::Augmented,
            &mut ::rusty_lr::builder::DiagnosticCollector::new(false),
        ) else {
            unreachable!("Failed to build LALR parser")
        };
        let states = states.states;
        let terminal_class_names = vec![
            "ident",
            "string_literal",
            "numeric_literal",
            "nil",
            "bool_",
            "plus",
            "minus",
            "asterisk",
            "slash",
            "percent",
            "caret",
            "hash",
            "ampersand",
            "tilde",
            "pipe",
            "lessless",
            "greatergreater",
            "slashslash",
            "equalequal",
            "tildeequal",
            "lessequal",
            "greaterequal",
            "less",
            "greater",
            "equal",
            "lparen",
            "rparen",
            "lbrace",
            "rbrace",
            "lbracket",
            "rbracket",
            "coloncolon",
            "semicolon",
            "colon",
            "comma",
            "dot",
            "dotdot",
            "dotdotdot",
            "and_",
            "break_",
            "do_",
            "else_",
            "elseif_",
            "end_",
            "for_",
            "function_",
            "goto_",
            "if_",
            "in_",
            "local_",
            "not_",
            "or_",
            "repeat_",
            "return_",
            "then_",
            "until_",
            "while_",
            "eof",
            "<Others>",
        ];
        let rules = builder
            .rules
            .into_iter()
            .map(move |rule| {
                rule.rule
                    .map(|term| terminal_class_names[term], |nonterm| nonterm)
            })
            .collect();
        let states: Vec<_> = states
            .into_iter()
            .map(|state| state.into_glr_sparse_state(|x| x, |x| x))
            .collect();
        Self {
            rules,
            states,
            classes: vec![
                vec!["ident"],
                vec!["string_literal"],
                vec!["numeric_literal"],
                vec!["nil"],
                vec!["bool_"],
                vec!["plus"],
                vec!["minus"],
                vec!["asterisk"],
                vec!["slash"],
                vec!["percent"],
                vec!["caret"],
                vec!["hash"],
                vec!["ampersand"],
                vec!["tilde"],
                vec!["pipe"],
                vec!["lessless"],
                vec!["greatergreater"],
                vec!["slashslash"],
                vec!["equalequal"],
                vec!["tildeequal"],
                vec!["lessequal"],
                vec!["greaterequal"],
                vec!["less"],
                vec!["greater"],
                vec!["equal"],
                vec!["lparen"],
                vec!["rparen"],
                vec!["lbrace"],
                vec!["rbrace"],
                vec!["lbracket"],
                vec!["rbracket"],
                vec!["coloncolon"],
                vec!["semicolon"],
                vec!["colon"],
                vec!["comma"],
                vec!["dot"],
                vec!["dotdot"],
                vec!["dotdotdot"],
                vec!["and_"],
                vec!["break_"],
                vec!["do_"],
                vec!["else_"],
                vec!["elseif_"],
                vec!["end_"],
                vec!["for_"],
                vec!["function_"],
                vec!["goto_"],
                vec!["if_"],
                vec!["in_"],
                vec!["local_"],
                vec!["not_"],
                vec!["or_"],
                vec!["repeat_"],
                vec!["return_"],
                vec!["then_"],
                vec!["until_"],
                vec!["while_"],
                vec!["eof"],
            ],
        }
    }
}
// ==============================Generated Codes End===============================
