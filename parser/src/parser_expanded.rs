
// This file was generated by rustylr 1.24.0
// This generated code is targeting rusty_lr version 3.31.0.
// There might be a build error if the version is not matched.
//
// ================================User Codes Begin================================
use lua_tokenizer::Token;
use lua_tokenizer::TokenType;
use crate::expression;
use crate::Expression;
use crate::statement;
use crate::Statement;
use crate::Span;
use crate::SpannedString;
use crate::ParseError;
use crate::ChunkOrExpressions;
macro_rules! new_binary_node {
    ($variant:ident, $op:ident, $lhs:ident, $rhs:ident) => {
        { let span = $lhs .span().merge_ordered(&$rhs .span()); let span_op = $op
        .span(); let binary_data = expression::ExprBinaryData::new($lhs, $rhs, span,
        span_op); Expression::Binary(expression::ExprBinary::$variant (binary_data)) }
    };
}
macro_rules! new_unary_node {
    ($variant:ident, $op:ident, $lhs:ident) => {
        { let span = $op .span().merge_ordered(&$lhs .span()); let span_op = $op .span();
        let unary_data = expression::ExprUnaryData::new($lhs, span, span_op);
        Expression::Unary(expression::ExprUnary::$variant (unary_data)) }
    };
}
fn filter(token: &Token) -> &TokenType {
    &token.token_type
}

// =================================User Codes End=================================
/*
====================================Grammar=====================================

# of terminal classes: 58
# of states: 221

0: ChunkOrExpressions -> Chunk
1: ChunkOrExpressions -> ExpList1
2: Chunk -> Block
3: Block -> Statement* ReturnStatement?
4: Statement -> semicolon
5: Statement -> VarList equal ExpList1
6: Statement -> FunctionCall
7: Statement -> coloncolon ident coloncolon
8: Statement -> break_
9: Statement -> goto_ ident
10: Statement -> do_ Block end_
11: Statement -> while_ Exp do_ Block end_
12: Statement -> repeat_ Block until_ Exp
13: Statement -> if_ Exp then_ Block ElseIf* (else_, Block)? end_
14: Statement -> for_ ident equal Exp comma Exp (comma, Exp)? do_ Block end_
15: Statement -> for_ NameList in_ ExpList1 do_ Block end_
16: Statement -> function_ FuncName FuncBody
17: Statement -> local_ function_ ident FuncBody
18: Statement -> local_ AttNameList (equal, ExpList1)?
19: ElseIf -> elseif_ Exp then_ Block
20: ReturnStatement -> return_ ExpList0 semicolon?
21: Var -> ident
22: Var -> PrefixExp lbracket Exp rbracket
23: Var -> PrefixExp dot ident
24: PrefixExp -> Var
25: PrefixExp -> FunctionCall
26: PrefixExp -> lparen Exp rparen
27: FunctionCall -> PrefixExp Args
28: FunctionCall -> PrefixExp colon ident Args
29: Args -> lparen ExpList0 rparen
30: Args -> TableConstructor
31: Args -> string_literal
32: VarList -> VarList comma Var
33: VarList -> Var
34: ExpList1 -> ExpList1 comma Exp
35: ExpList1 -> Exp
36: ExpList0 -> ExpList1
37: ExpList0 -> 
38: NameList -> NameList comma ident
39: NameList -> ident
40: AttName -> ident Attrib
41: AttNameList -> AttNameList comma AttName
42: AttNameList -> AttName
43: Attrib -> less ident greater
44: Attrib -> 
45: Exp -> numeric_literal
46: Exp -> nil
47: Exp -> string_literal
48: Exp -> bool_
49: Exp -> dotdotdot
50: Exp -> FunctionDef
51: Exp -> PrefixExp
52: Exp -> TableConstructor
53: Exp -> not_ Exp
54: Exp -> hash Exp
55: Exp -> minus Exp
56: Exp -> plus Exp
57: Exp -> tilde Exp
58: Exp -> Exp asterisk Exp
59: Exp -> Exp slash Exp
60: Exp -> Exp slashslash Exp
61: Exp -> Exp percent Exp
62: Exp -> Exp plus Exp
63: Exp -> Exp minus Exp
64: Exp -> Exp dotdot Exp
65: Exp -> Exp lessless Exp
66: Exp -> Exp greatergreater Exp
67: Exp -> Exp ampersand Exp
68: Exp -> Exp tilde Exp
69: Exp -> Exp pipe Exp
70: Exp -> Exp less Exp
71: Exp -> Exp lessequal Exp
72: Exp -> Exp greater Exp
73: Exp -> Exp greaterequal Exp
74: Exp -> Exp tildeequal Exp
75: Exp -> Exp equalequal Exp
76: Exp -> Exp and_ Exp
77: Exp -> Exp or_ Exp
78: Exp -> Exp caret Exp
79: TableConstructor -> lbrace FieldList rbrace
80: FieldList -> $sep(Field, FieldSep, *)
81: Field -> lbracket Exp rbracket equal Exp
82: Field -> ident equal Exp
83: Field -> Exp
84: FieldSep -> comma
85: FieldSep -> semicolon
86: FunctionDef -> function_ FuncBody
87: FuncBody -> lparen ParList? rparen Block end_
88: FuncName1 -> FuncName1 dot ident
89: FuncName1 -> ident
90: FuncName -> FuncName1 colon ident
91: FuncName -> FuncName1
92: ParList -> NameList (comma, dotdotdot)?
93: ParList -> dotdotdot
94: Statement+ -> Statement
95: Statement+ -> Statement+ Statement
96: Statement* -> Statement+
97: Statement* -> 
98: ReturnStatement? -> ReturnStatement
99: ReturnStatement? -> 
100: ElseIf+ -> ElseIf
101: ElseIf+ -> ElseIf+ ElseIf
102: ElseIf* -> ElseIf+
103: ElseIf* -> 
104: (else_, Block) -> else_ Block
105: (else_, Block)? -> (else_, Block)
106: (else_, Block)? -> 
107: (comma, Exp) -> comma Exp
108: (comma, Exp)? -> (comma, Exp)
109: (comma, Exp)? -> 
110: (equal, ExpList1) -> equal ExpList1
111: (equal, ExpList1)? -> (equal, ExpList1)
112: (equal, ExpList1)? -> 
113: semicolon? -> semicolon
114: semicolon? -> 
115: $sep(Field, FieldSep, +) -> Field
116: $sep(Field, FieldSep, +) -> $sep(Field, FieldSep, +) FieldSep Field
117: $sep(Field, FieldSep, *) -> $sep(Field, FieldSep, +)
118: $sep(Field, FieldSep, *) -> 
119: ParList? -> ParList
120: ParList? -> 
121: (comma, dotdotdot) -> comma dotdotdot
122: (comma, dotdotdot)? -> (comma, dotdotdot)
123: (comma, dotdotdot)? -> 
124: Augmented -> ChunkOrExpressions eof

*/
// =============================Generated Codes Begin==============================
/// type alias for `Context`
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsContext = ::rusty_lr::parser::nondeterministic::Context<
    ChunkOrExpressionsDataStack,
    u8,
>;
/// type alias for CFG production rule
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsRule = ::rusty_lr::rule::ProductionRule<
    &'static str,
    ChunkOrExpressionsNonTerminals,
>;
/// type alias for DFA state
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsState = ::rusty_lr::parser::state::SparseState<
    u8,
    ChunkOrExpressionsNonTerminals,
    ::rusty_lr::parser::state::SmallVecU8,
    u8,
>;
/// type alias for `InvalidTerminalError`
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsParseError = ::rusty_lr::parser::nondeterministic::ParseError<
    ChunkOrExpressionsDataStack,
>;
/// An enum that represents non-terminal symbols
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std::hash::Hash,
    std::cmp::PartialEq,
    std::cmp::Eq,
    std::cmp::PartialOrd,
    std::cmp::Ord
)]
pub enum ChunkOrExpressionsNonTerminals {
    ChunkOrExpressions,
    Chunk,
    Block,
    Statement,
    ElseIf,
    ReturnStatement,
    Var,
    PrefixExp,
    FunctionCall,
    Args,
    VarList,
    ExpList1,
    ExpList0,
    NameList,
    AttName,
    AttNameList,
    Attrib,
    Exp,
    TableConstructor,
    FieldList,
    Field,
    FieldSep,
    FunctionDef,
    FuncBody,
    FuncName1,
    FuncName,
    ParList,
    _StatementPlus27,
    _StatementStar28,
    _ReturnStatementQuestion29,
    _ElseIfPlus30,
    _ElseIfStar31,
    _Group32,
    __Group32Question33,
    _Group34,
    __Group34Question35,
    _Group36,
    __Group36Question37,
    _semicolonQuestion38,
    _FieldSepPlus39,
    _FieldSepStar40,
    _ParListQuestion41,
    _Group42,
    __Group42Question43,
    Augmented,
}
impl std::fmt::Display for ChunkOrExpressionsNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for ChunkOrExpressionsNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        use ::rusty_lr::nonterminal::NonTerminal;
        write!(f, "{}", self.as_str())
    }
}
impl ::rusty_lr::nonterminal::NonTerminal for ChunkOrExpressionsNonTerminals {
    fn as_str(&self) -> &'static str {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => "ChunkOrExpressions",
            ChunkOrExpressionsNonTerminals::Chunk => "Chunk",
            ChunkOrExpressionsNonTerminals::Block => "Block",
            ChunkOrExpressionsNonTerminals::Statement => "Statement",
            ChunkOrExpressionsNonTerminals::ElseIf => "ElseIf",
            ChunkOrExpressionsNonTerminals::ReturnStatement => "ReturnStatement",
            ChunkOrExpressionsNonTerminals::Var => "Var",
            ChunkOrExpressionsNonTerminals::PrefixExp => "PrefixExp",
            ChunkOrExpressionsNonTerminals::FunctionCall => "FunctionCall",
            ChunkOrExpressionsNonTerminals::Args => "Args",
            ChunkOrExpressionsNonTerminals::VarList => "VarList",
            ChunkOrExpressionsNonTerminals::ExpList1 => "ExpList1",
            ChunkOrExpressionsNonTerminals::ExpList0 => "ExpList0",
            ChunkOrExpressionsNonTerminals::NameList => "NameList",
            ChunkOrExpressionsNonTerminals::AttName => "AttName",
            ChunkOrExpressionsNonTerminals::AttNameList => "AttNameList",
            ChunkOrExpressionsNonTerminals::Attrib => "Attrib",
            ChunkOrExpressionsNonTerminals::Exp => "Exp",
            ChunkOrExpressionsNonTerminals::TableConstructor => "TableConstructor",
            ChunkOrExpressionsNonTerminals::FieldList => "FieldList",
            ChunkOrExpressionsNonTerminals::Field => "Field",
            ChunkOrExpressionsNonTerminals::FieldSep => "FieldSep",
            ChunkOrExpressionsNonTerminals::FunctionDef => "FunctionDef",
            ChunkOrExpressionsNonTerminals::FuncBody => "FuncBody",
            ChunkOrExpressionsNonTerminals::FuncName1 => "FuncName1",
            ChunkOrExpressionsNonTerminals::FuncName => "FuncName",
            ChunkOrExpressionsNonTerminals::ParList => "ParList",
            ChunkOrExpressionsNonTerminals::_StatementPlus27 => "Statement+",
            ChunkOrExpressionsNonTerminals::_StatementStar28 => "Statement*",
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion29 => {
                "ReturnStatement?"
            }
            ChunkOrExpressionsNonTerminals::_ElseIfPlus30 => "ElseIf+",
            ChunkOrExpressionsNonTerminals::_ElseIfStar31 => "ElseIf*",
            ChunkOrExpressionsNonTerminals::_Group32 => "(else_, Block)",
            ChunkOrExpressionsNonTerminals::__Group32Question33 => "(else_, Block)?",
            ChunkOrExpressionsNonTerminals::_Group34 => "(comma, Exp)",
            ChunkOrExpressionsNonTerminals::__Group34Question35 => "(comma, Exp)?",
            ChunkOrExpressionsNonTerminals::_Group36 => "(equal, ExpList1)",
            ChunkOrExpressionsNonTerminals::__Group36Question37 => "(equal, ExpList1)?",
            ChunkOrExpressionsNonTerminals::_semicolonQuestion38 => "semicolon?",
            ChunkOrExpressionsNonTerminals::_FieldSepPlus39 => "$sep(Field, FieldSep, +)",
            ChunkOrExpressionsNonTerminals::_FieldSepStar40 => "$sep(Field, FieldSep, *)",
            ChunkOrExpressionsNonTerminals::_ParListQuestion41 => "ParList?",
            ChunkOrExpressionsNonTerminals::_Group42 => "(comma, dotdotdot)",
            ChunkOrExpressionsNonTerminals::__Group42Question43 => "(comma, dotdotdot)?",
            ChunkOrExpressionsNonTerminals::Augmented => "Augmented",
        }
    }
    fn is_trace(&self) -> bool {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => false,
            ChunkOrExpressionsNonTerminals::Chunk => false,
            ChunkOrExpressionsNonTerminals::Block => false,
            ChunkOrExpressionsNonTerminals::Statement => false,
            ChunkOrExpressionsNonTerminals::ElseIf => false,
            ChunkOrExpressionsNonTerminals::ReturnStatement => false,
            ChunkOrExpressionsNonTerminals::Var => false,
            ChunkOrExpressionsNonTerminals::PrefixExp => false,
            ChunkOrExpressionsNonTerminals::FunctionCall => false,
            ChunkOrExpressionsNonTerminals::Args => false,
            ChunkOrExpressionsNonTerminals::VarList => false,
            ChunkOrExpressionsNonTerminals::ExpList1 => false,
            ChunkOrExpressionsNonTerminals::ExpList0 => false,
            ChunkOrExpressionsNonTerminals::NameList => false,
            ChunkOrExpressionsNonTerminals::AttName => false,
            ChunkOrExpressionsNonTerminals::AttNameList => false,
            ChunkOrExpressionsNonTerminals::Attrib => false,
            ChunkOrExpressionsNonTerminals::Exp => false,
            ChunkOrExpressionsNonTerminals::TableConstructor => false,
            ChunkOrExpressionsNonTerminals::FieldList => false,
            ChunkOrExpressionsNonTerminals::Field => false,
            ChunkOrExpressionsNonTerminals::FieldSep => false,
            ChunkOrExpressionsNonTerminals::FunctionDef => false,
            ChunkOrExpressionsNonTerminals::FuncBody => false,
            ChunkOrExpressionsNonTerminals::FuncName1 => false,
            ChunkOrExpressionsNonTerminals::FuncName => false,
            ChunkOrExpressionsNonTerminals::ParList => false,
            ChunkOrExpressionsNonTerminals::_StatementPlus27 => false,
            ChunkOrExpressionsNonTerminals::_StatementStar28 => false,
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion29 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfPlus30 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfStar31 => false,
            ChunkOrExpressionsNonTerminals::_Group32 => false,
            ChunkOrExpressionsNonTerminals::__Group32Question33 => false,
            ChunkOrExpressionsNonTerminals::_Group34 => false,
            ChunkOrExpressionsNonTerminals::__Group34Question35 => false,
            ChunkOrExpressionsNonTerminals::_Group36 => false,
            ChunkOrExpressionsNonTerminals::__Group36Question37 => false,
            ChunkOrExpressionsNonTerminals::_semicolonQuestion38 => false,
            ChunkOrExpressionsNonTerminals::_FieldSepPlus39 => false,
            ChunkOrExpressionsNonTerminals::_FieldSepStar40 => false,
            ChunkOrExpressionsNonTerminals::_ParListQuestion41 => false,
            ChunkOrExpressionsNonTerminals::_Group42 => false,
            ChunkOrExpressionsNonTerminals::__Group42Question43 => false,
            ChunkOrExpressionsNonTerminals::Augmented => false,
        }
    }
    fn nonterm_type(&self) -> Option<::rusty_lr::nonterminal::NonTerminalType> {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => None,
            ChunkOrExpressionsNonTerminals::Chunk => None,
            ChunkOrExpressionsNonTerminals::Block => None,
            ChunkOrExpressionsNonTerminals::Statement => None,
            ChunkOrExpressionsNonTerminals::ElseIf => None,
            ChunkOrExpressionsNonTerminals::ReturnStatement => None,
            ChunkOrExpressionsNonTerminals::Var => None,
            ChunkOrExpressionsNonTerminals::PrefixExp => None,
            ChunkOrExpressionsNonTerminals::FunctionCall => None,
            ChunkOrExpressionsNonTerminals::Args => None,
            ChunkOrExpressionsNonTerminals::VarList => None,
            ChunkOrExpressionsNonTerminals::ExpList1 => None,
            ChunkOrExpressionsNonTerminals::ExpList0 => None,
            ChunkOrExpressionsNonTerminals::NameList => None,
            ChunkOrExpressionsNonTerminals::AttName => None,
            ChunkOrExpressionsNonTerminals::AttNameList => None,
            ChunkOrExpressionsNonTerminals::Attrib => None,
            ChunkOrExpressionsNonTerminals::Exp => None,
            ChunkOrExpressionsNonTerminals::TableConstructor => None,
            ChunkOrExpressionsNonTerminals::FieldList => None,
            ChunkOrExpressionsNonTerminals::Field => None,
            ChunkOrExpressionsNonTerminals::FieldSep => None,
            ChunkOrExpressionsNonTerminals::FunctionDef => None,
            ChunkOrExpressionsNonTerminals::FuncBody => None,
            ChunkOrExpressionsNonTerminals::FuncName1 => None,
            ChunkOrExpressionsNonTerminals::FuncName => None,
            ChunkOrExpressionsNonTerminals::ParList => None,
            ChunkOrExpressionsNonTerminals::_StatementPlus27 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::PlusLeft)
            }
            ChunkOrExpressionsNonTerminals::_StatementStar28 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Star)
            }
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion29 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_ElseIfPlus30 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::PlusLeft)
            }
            ChunkOrExpressionsNonTerminals::_ElseIfStar31 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Star)
            }
            ChunkOrExpressionsNonTerminals::_Group32 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Group)
            }
            ChunkOrExpressionsNonTerminals::__Group32Question33 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_Group34 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Group)
            }
            ChunkOrExpressionsNonTerminals::__Group34Question35 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_Group36 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Group)
            }
            ChunkOrExpressionsNonTerminals::__Group36Question37 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_semicolonQuestion38 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_FieldSepPlus39 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::PlusLeft)
            }
            ChunkOrExpressionsNonTerminals::_FieldSepStar40 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Star)
            }
            ChunkOrExpressionsNonTerminals::_ParListQuestion41 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::_Group42 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Group)
            }
            ChunkOrExpressionsNonTerminals::__Group42Question43 => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Optional)
            }
            ChunkOrExpressionsNonTerminals::Augmented => {
                Some(::rusty_lr::nonterminal::NonTerminalType::Augmented)
            }
        }
    }
    fn to_usize(&self) -> usize {
        *self as usize
    }
}
/// tag for token that represents which stack a token is using
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum ChunkOrExpressionsTags {
    __terminals,
    __stack2,
    __stack3,
    __stack4,
    __stack5,
    __stack6,
    __stack7,
    __stack8,
    __stack9,
    __stack10,
    __stack11,
    __stack12,
    __stack13,
    __stack14,
    __stack15,
    __stack16,
    __stack17,
    __stack18,
    __stack19,
    __stack20,
    __stack21,
    __stack22,
    __stack23,
    __stack24,
    __stack25,
    __stack26,
    __stack27,
    __stack28,
    Empty,
}
/// enum for each non-terminal and terminal symbol, that actually hold data
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone)]
pub struct ChunkOrExpressionsDataStack {
    pub __tags: Vec<ChunkOrExpressionsTags>,
    __terminals: Vec<Token>,
    __stack2: Vec<ChunkOrExpressions>,
    __stack3: Vec<statement::Block>,
    __stack4: Vec<Statement>,
    __stack5: Vec<statement::StmtElseIf>,
    __stack6: Vec<statement::ReturnStatement>,
    __stack7: Vec<Expression>,
    __stack8: Vec<expression::ExprFunctionCall>,
    __stack9: Vec<expression::FunctionCallArguments>,
    __stack10: Vec<Vec<Expression>>,
    __stack11: Vec<Vec<SpannedString>>,
    __stack12: Vec<statement::AttName>,
    __stack13: Vec<Vec<statement::AttName>>,
    __stack14: Vec<Option<statement::Attrib>>,
    __stack15: Vec<expression::ExprTable>,
    __stack16: Vec<Vec<expression::TableField>>,
    __stack17: Vec<expression::TableField>,
    __stack18: Vec<expression::ExprFunction>,
    __stack19: Vec<statement::FunctionName>,
    __stack20: Vec<expression::ParameterList>,
    __stack21: Vec<Vec<Statement>>,
    __stack22: Vec<Option<statement::ReturnStatement>>,
    __stack23: Vec<Vec<statement::StmtElseIf>>,
    __stack24: Vec<Option<statement::Block>>,
    __stack25: Vec<Option<Expression>>,
    __stack26: Vec<Option<Vec<Expression>>>,
    __stack27: Vec<Option<Token>>,
    __stack28: Vec<Option<expression::ParameterList>>,
}
impl Default for ChunkOrExpressionsDataStack {
    fn default() -> Self {
        Self {
            __tags: Vec::new(),
            __terminals: Vec::new(),
            __stack2: Vec::new(),
            __stack3: Vec::new(),
            __stack4: Vec::new(),
            __stack5: Vec::new(),
            __stack6: Vec::new(),
            __stack7: Vec::new(),
            __stack8: Vec::new(),
            __stack9: Vec::new(),
            __stack10: Vec::new(),
            __stack11: Vec::new(),
            __stack12: Vec::new(),
            __stack13: Vec::new(),
            __stack14: Vec::new(),
            __stack15: Vec::new(),
            __stack16: Vec::new(),
            __stack17: Vec::new(),
            __stack18: Vec::new(),
            __stack19: Vec::new(),
            __stack20: Vec::new(),
            __stack21: Vec::new(),
            __stack22: Vec::new(),
            __stack23: Vec::new(),
            __stack24: Vec::new(),
            __stack25: Vec::new(),
            __stack26: Vec::new(),
            __stack27: Vec::new(),
            __stack28: Vec::new(),
        }
    }
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl ChunkOrExpressionsDataStack {
    ///ChunkOrExpressions -> Chunk
    #[inline]
    fn reduce_ChunkOrExpressions_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack2);
        let mut Chunk = __data_stack.__stack3.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { ChunkOrExpressions::Chunk(Chunk) };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///ChunkOrExpressions -> ExpList1
    #[inline]
    fn reduce_ChunkOrExpressions_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack2);
        let mut ExpList1 = __data_stack.__stack10.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { ChunkOrExpressions::Expressions(ExpList1) };
        __data_stack.__stack2.push(__res);
        Ok(true)
    }
    ///Block -> Statement* ReturnStatement?
    #[inline]
    fn reduce_Block_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack22)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack21)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack3);
        let mut Statement = __data_stack.__stack21.pop().unwrap();
        let mut ReturnStatement = __data_stack.__stack22.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let span0 = if let Some(first) = Statement.first() {
                first.span()
            } else {
                Span::new_none()
            };
            if let Some(ret) = ReturnStatement {
                let span1 = ret.span();
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, Some(ret), span)
            } else {
                let span1 = if let Some(last) = Statement.last() {
                    last.span()
                } else {
                    Span::new_none()
                };
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, None, span)
            }
        };
        __data_stack.__stack3.push(__res);
        Ok(true)
    }
    ///Statement -> semicolon
    #[inline]
    fn reduce_Statement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut semicolon = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Statement::None(statement::StmtNone::new(semicolon.span())) };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> VarList equal ExpList1
    #[inline]
    fn reduce_Statement_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut ExpList1 = __data_stack.__stack10.pop().unwrap();
        let mut VarList = __data_stack.__stack10.pop().unwrap();
        let mut equal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = VarList
                .first()
                .unwrap()
                .span()
                .merge_ordered(&ExpList1.last().unwrap().span());
            let span_eq = equal.span();
            Statement::Assignment(
                statement::StmtAssignment::new(VarList, ExpList1, span, span_eq),
            )
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> FunctionCall
    #[inline]
    fn reduce_Statement_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack8)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut FunctionCall = __data_stack.__stack8.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Statement::FunctionCall(FunctionCall) };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> coloncolon ident coloncolon
    #[inline]
    fn reduce_Statement_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut c2 = __data_stack.__terminals.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        let mut c1 = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = c1.span().merge_ordered(&c2.span());
            Statement::Label(statement::StmtLabel::new(ident.into(), span))
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> break_
    #[inline]
    fn reduce_Statement_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut break_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Statement::Break(statement::StmtBreak::new(break_.span())) };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> goto_ ident
    #[inline]
    fn reduce_Statement_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        let mut goto_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let span = goto_.span().merge_ordered(&ident.span());
            Statement::Goto(statement::StmtGoto::new(ident.into(), span))
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> do_ Block end_
    #[inline]
    fn reduce_Statement_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut end_ = __data_stack.__terminals.pop().unwrap();
        let mut do_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = do_.span().merge_ordered(&end_.span());
            Statement::Do(statement::StmtDo::new(Block, span))
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> while_ Exp do_ Block end_
    #[inline]
    fn reduce_Statement_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut end_ = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut while_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            let span = while_.span().merge_ordered(&end_.span());
            Statement::While(statement::StmtWhile::new(Exp, Block, span))
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> repeat_ Block until_ Exp
    #[inline]
    fn reduce_Statement_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut repeat_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            let span = repeat_.span().merge_ordered(&Exp.span());
            Statement::Repeat(statement::StmtRepeat::new(Block, Exp, span))
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> if_ Exp then_ Block ElseIf* (else_, Block)? end_
    #[inline]
    fn reduce_Statement_9(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack24)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack23)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 7usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut elseifs = __data_stack.__stack23.pop().unwrap();
        let mut else_ = __data_stack.__stack24.pop().unwrap();
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut end_ = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut if_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 7usize);
        let __res = {
            let span = if_.span().merge_ordered(&end_.span());
            Statement::If(statement::StmtIf::new(Exp, Block, elseifs, else_, span))
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> for_ ident equal Exp comma Exp (comma, Exp)? do_ Block end_
    #[inline]
    fn reduce_Statement_10(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack25)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 7usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 8usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 9usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 10usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut step = __data_stack.__stack25.pop().unwrap();
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut end = __data_stack.__stack7.pop().unwrap();
        let mut start = __data_stack.__stack7.pop().unwrap();
        let mut end_ = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 3usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        let mut for_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 10usize);
        let __res = {
            let span = for_.span().merge_ordered(&end_.span());
            Statement::For(
                statement::StmtFor::new(
                    ident.token_type.into_ident().unwrap(),
                    start,
                    end,
                    step
                        .unwrap_or_else(|| {
                            Expression::Numeric(
                                expression::ExprNumeric::new(1.into(), Span::new_none()),
                            )
                        }),
                    Block,
                    span,
                ),
            )
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> for_ NameList in_ ExpList1 do_ Block end_
    #[inline]
    fn reduce_Statement_11(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 5usize) == Some(&
                ChunkOrExpressionsTags::__stack11)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 6usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 7usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut ExpList1 = __data_stack.__stack10.pop().unwrap();
        let mut NameList = __data_stack.__stack11.pop().unwrap();
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut end_ = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut for_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 7usize);
        let __res = {
            let span = for_.span().merge_ordered(&end_.span());
            Statement::ForGeneric(
                statement::StmtForGeneric::new(NameList, ExpList1, Block, span),
            )
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> function_ FuncName FuncBody
    #[inline]
    fn reduce_Statement_12(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack19)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut FuncBody = __data_stack.__stack18.pop().unwrap();
        let mut FuncName = __data_stack.__stack19.pop().unwrap();
        let mut function_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = function_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinition(
                statement::StmtFunctionDefinition::new(FuncName, FuncBody, span),
            )
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> local_ function_ ident FuncBody
    #[inline]
    fn reduce_Statement_13(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut FuncBody = __data_stack.__stack18.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut local_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            let span = local_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinitionLocal(
                statement::StmtFunctionDefinitionLocal::new(ident.into(), FuncBody, span),
            )
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///Statement -> local_ AttNameList (equal, ExpList1)?
    #[inline]
    fn reduce_Statement_14(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack26)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack13)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack4);
        let mut AttNameList = __data_stack.__stack13.pop().unwrap();
        let mut rhs_list = __data_stack.__stack26.pop().unwrap();
        let mut local_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span0 = local_.span();
            if let Some(rhs) = rhs_list {
                let span = span0.merge_ordered(&rhs.last().unwrap().span());
                Statement::LocalDeclaration(
                    statement::StmtLocalDeclaration::new(AttNameList, Some(rhs), span),
                )
            } else {
                let span = AttNameList.last().unwrap().span();
                Statement::LocalDeclaration(
                    statement::StmtLocalDeclaration::new(AttNameList, None, span),
                )
            }
        };
        __data_stack.__stack4.push(__res);
        Ok(true)
    }
    ///ElseIf -> elseif_ Exp then_ Block
    #[inline]
    fn reduce_ElseIf_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack5);
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut then_ = __data_stack.__terminals.pop().unwrap();
        let mut elseif_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            let span = if Block.span().is_none() {
                elseif_.span().merge_ordered(&then_.span())
            } else {
                elseif_.span().merge_ordered(&Block.span())
            };
            statement::StmtElseIf::new(Exp, Block, span)
        };
        __data_stack.__stack5.push(__res);
        Ok(true)
    }
    ///ReturnStatement -> return_ ExpList0 semicolon?
    #[inline]
    fn reduce_ReturnStatement_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack27)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack6);
        let mut ExpList0 = __data_stack.__stack10.pop().unwrap();
        let mut semicolon = __data_stack.__stack27.pop().unwrap();
        let mut return_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span0 = return_.span();
            let span = if let Some(last) = semicolon {
                span0.merge_ordered(&last.span())
            } else {
                if let Some(last) = ExpList0.last() {
                    span0.merge_ordered(&last.span())
                } else {
                    span0
                }
            };
            statement::ReturnStatement::new(ExpList0, span)
        };
        __data_stack.__stack6.push(__res);
        Ok(true)
    }
    ///Var -> ident
    #[inline]
    fn reduce_Var_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::Ident(ident.into()) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Var -> PrefixExp lbracket Exp rbracket
    #[inline]
    fn reduce_Var_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut PrefixExp = __data_stack.__stack7.pop().unwrap();
        let mut rbracket = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            let span = PrefixExp.span().merge_ordered(&rbracket.span());
            Expression::TableIndex(expression::ExprTableIndex::new(PrefixExp, Exp, span))
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Var -> PrefixExp dot ident
    #[inline]
    fn reduce_Var_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut PrefixExp = __data_stack.__stack7.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = PrefixExp.span().merge_ordered(&ident.span());
            let member = expression::ExprString::from(ident);
            Expression::TableIndex(
                expression::ExprTableIndex::new(
                    PrefixExp,
                    Expression::String(member),
                    span,
                ),
            )
        };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///PrefixExp -> Var
    #[inline(always)]
    fn reduce_PrefixExp_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __location_stack.truncate(__location_stack.len() - 1usize);
        true
    }
    ///PrefixExp -> FunctionCall
    #[inline]
    fn reduce_PrefixExp_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack8)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut FunctionCall = __data_stack.__stack8.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::FunctionCall(FunctionCall) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///PrefixExp -> lparen Exp rparen
    #[inline(always)]
    fn reduce_PrefixExp_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        true
    }
    ///FunctionCall -> PrefixExp Args
    #[inline]
    fn reduce_FunctionCall_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack9)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack8);
        let mut PrefixExp = __data_stack.__stack7.pop().unwrap();
        let mut Args = __data_stack.__stack9.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, None, Args, span)
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///FunctionCall -> PrefixExp colon ident Args
    #[inline]
    fn reduce_FunctionCall_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack9)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 4usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack8);
        let mut PrefixExp = __data_stack.__stack7.pop().unwrap();
        let mut Args = __data_stack.__stack9.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 4usize);
        let __res = {
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, Some(ident.into()), Args, span)
        };
        __data_stack.__stack8.push(__res);
        Ok(true)
    }
    ///Args -> lparen ExpList0 rparen
    #[inline]
    fn reduce_Args_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack9);
        let mut ExpList0 = __data_stack.__stack10.pop().unwrap();
        let mut rparen = __data_stack.__terminals.pop().unwrap();
        let mut lparen = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = lparen.span().merge_ordered(&rparen.span());
            expression::FunctionCallArguments::new(ExpList0, span)
        };
        __data_stack.__stack9.push(__res);
        Ok(true)
    }
    ///Args -> TableConstructor
    #[inline]
    fn reduce_Args_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack15)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack9);
        let mut TableConstructor = __data_stack.__stack15.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let span = TableConstructor.span();
            let table_expr = Expression::Table(TableConstructor);
            let exprs = vec![table_expr];
            expression::FunctionCallArguments::new(exprs, span)
        };
        __data_stack.__stack9.push(__res);
        Ok(true)
    }
    ///Args -> string_literal
    #[inline]
    fn reduce_Args_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack9);
        let mut string_literal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let span = string_literal.span();
            let exprs = vec![Expression::String(string_literal.into())];
            expression::FunctionCallArguments::new(exprs, span)
        };
        __data_stack.__stack9.push(__res);
        Ok(true)
    }
    ///VarList -> VarList comma Var
    #[inline]
    fn reduce_VarList_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut VarList = __data_stack.__stack10.pop().unwrap();
        let mut Var = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            VarList.push(Var);
            VarList
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///VarList -> Var
    #[inline]
    fn reduce_VarList_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack10);
        let mut Var = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![Var] };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///ExpList1 -> ExpList1 comma Exp
    #[inline]
    fn reduce_ExpList1_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut ExpList1 = __data_stack.__stack10.pop().unwrap();
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            ExpList1.push(Exp);
            ExpList1
        };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///ExpList1 -> Exp
    #[inline]
    fn reduce_ExpList1_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack10);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![Exp] };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///ExpList0 -> ExpList1
    #[inline]
    fn reduce_ExpList0_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
        }
        let mut ExpList1 = __data_stack.__stack10.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { ExpList1 };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///ExpList0 ->
    #[inline]
    fn reduce_ExpList0_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack10);
        let __res = { vec![] };
        __data_stack.__stack10.push(__res);
        Ok(true)
    }
    ///NameList -> NameList comma ident
    #[inline]
    fn reduce_NameList_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack11)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut NameList = __data_stack.__stack11.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            NameList.push(ident.into());
            NameList
        };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///NameList -> ident
    #[inline]
    fn reduce_NameList_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack11);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![ident.into()] };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///AttName -> ident Attrib
    #[inline]
    fn reduce_AttName_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack14)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack12);
        let mut Attrib = __data_stack.__stack14.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let span = ident.span();
            statement::AttName::new(ident.into(), Attrib, span)
        };
        __data_stack.__stack12.push(__res);
        Ok(true)
    }
    ///AttNameList -> AttNameList comma AttName
    #[inline]
    fn reduce_AttNameList_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack12)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack13)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut AttName = __data_stack.__stack12.pop().unwrap();
        let mut AttNameList = __data_stack.__stack13.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            AttNameList.push(AttName);
            AttNameList
        };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///AttNameList -> AttName
    #[inline]
    fn reduce_AttNameList_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack12)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack13);
        let mut AttName = __data_stack.__stack12.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![AttName] };
        __data_stack.__stack13.push(__res);
        Ok(true)
    }
    ///Attrib -> less ident greater
    #[inline]
    fn reduce_Attrib_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack14);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let s: SpannedString = ident.into();
            match s.as_str() {
                "const" => Some(statement::Attrib::Const),
                "close" => Some(statement::Attrib::Close),
                _ => {
                    return Err(ParseError::UnknownAttribute(s));
                }
            }
        };
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///Attrib ->
    #[inline]
    fn reduce_Attrib_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack14);
        let __res = { None };
        __data_stack.__stack14.push(__res);
        Ok(true)
    }
    ///Exp -> numeric_literal
    #[inline]
    fn reduce_Exp_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut numeric_literal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::Numeric(numeric_literal.into()) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> nil
    #[inline]
    fn reduce_Exp_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut nil = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::Nil(nil.into()) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> string_literal
    #[inline]
    fn reduce_Exp_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut string_literal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::String(string_literal.into()) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> bool_
    #[inline]
    fn reduce_Exp_3(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut bool_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::Bool(bool_.into()) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> dotdotdot
    #[inline]
    fn reduce_Exp_4(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut dotdotdot = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::Variadic(dotdotdot.into()) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> FunctionDef
    #[inline]
    fn reduce_Exp_5(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack18)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut FunctionDef = __data_stack.__stack18.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::Function(FunctionDef) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> PrefixExp
    #[inline(always)]
    fn reduce_Exp_6(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __location_stack.truncate(__location_stack.len() - 1usize);
        true
    }
    ///Exp -> TableConstructor
    #[inline]
    fn reduce_Exp_7(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack15)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut TableConstructor = __data_stack.__stack15.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { Expression::Table(TableConstructor) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> not_ Exp
    #[inline]
    fn reduce_Exp_8(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut not_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = { new_unary_node!(LogicalNot, not_, Exp) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> hash Exp
    #[inline]
    fn reduce_Exp_9(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut hash = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = { new_unary_node!(Length, hash, Exp) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> minus Exp
    #[inline]
    fn reduce_Exp_10(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut minus = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = { new_unary_node!(Minus, minus, Exp) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> plus Exp
    #[inline]
    fn reduce_Exp_11(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut plus = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = { new_unary_node!(Plus, plus, Exp) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> tilde Exp
    #[inline]
    fn reduce_Exp_12(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        let mut tilde = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = { new_unary_node!(BitwiseNot, tilde, Exp) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp asterisk Exp
    #[inline]
    fn reduce_Exp_13(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut asterisk = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Mul, asterisk, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp slash Exp
    #[inline]
    fn reduce_Exp_14(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut slash = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Div, slash, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp slashslash Exp
    #[inline]
    fn reduce_Exp_15(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut slashslash = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(FloorDiv, slashslash, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp percent Exp
    #[inline]
    fn reduce_Exp_16(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut percent = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Mod, percent, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp plus Exp
    #[inline]
    fn reduce_Exp_17(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut plus = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Add, plus, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp minus Exp
    #[inline]
    fn reduce_Exp_18(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut minus = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Sub, minus, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp dotdot Exp
    #[inline]
    fn reduce_Exp_19(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut dotdot = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Concat, dotdot, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp lessless Exp
    #[inline]
    fn reduce_Exp_20(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut lessless = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(ShiftLeft, lessless, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp greatergreater Exp
    #[inline]
    fn reduce_Exp_21(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut greatergreater = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(ShiftRight, greatergreater, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp ampersand Exp
    #[inline]
    fn reduce_Exp_22(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut ampersand = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(BitwiseAnd, ampersand, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp tilde Exp
    #[inline]
    fn reduce_Exp_23(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut tilde = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(BitwiseXor, tilde, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp pipe Exp
    #[inline]
    fn reduce_Exp_24(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut pipe = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(BitwiseOr, pipe, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp less Exp
    #[inline]
    fn reduce_Exp_25(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut less = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(LessThan, less, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp lessequal Exp
    #[inline]
    fn reduce_Exp_26(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut lessequal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(LessEqual, lessequal, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp greater Exp
    #[inline]
    fn reduce_Exp_27(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut greater = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(GreaterThan, greater, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp greaterequal Exp
    #[inline]
    fn reduce_Exp_28(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut greaterequal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(GreaterEqual, greaterequal, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp tildeequal Exp
    #[inline]
    fn reduce_Exp_29(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut tildeequal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(NotEqual, tildeequal, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp equalequal Exp
    #[inline]
    fn reduce_Exp_30(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut equalequal = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Equal, equalequal, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp and_ Exp
    #[inline]
    fn reduce_Exp_31(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut and_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(LogicalAnd, and_, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp or_ Exp
    #[inline]
    fn reduce_Exp_32(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut or_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(LogicalOr, or_, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///Exp -> Exp caret Exp
    #[inline]
    fn reduce_Exp_33(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut rhs = __data_stack.__stack7.pop().unwrap();
        let mut lhs = __data_stack.__stack7.pop().unwrap();
        let mut caret = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = { new_binary_node!(Pow, caret, lhs, rhs) };
        __data_stack.__stack7.push(__res);
        Ok(true)
    }
    ///TableConstructor -> lbrace FieldList rbrace
    #[inline]
    fn reduce_TableConstructor_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack16)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack15);
        let mut FieldList = __data_stack.__stack16.pop().unwrap();
        let mut rbrace = __data_stack.__terminals.pop().unwrap();
        let mut lbrace = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = lbrace.span().merge_ordered(&rbrace.span());
            expression::ExprTable::new(FieldList, span)
        };
        __data_stack.__stack15.push(__res);
        Ok(true)
    }
    ///Field -> lbracket Exp rbracket equal Exp
    #[inline]
    fn reduce_Field_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack17);
        let mut v = __data_stack.__stack7.pop().unwrap();
        let mut k = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 2usize);
        let mut lbracket = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            let span = lbracket.span().merge_ordered(&v.span());
            expression::TableField::KeyValue(
                expression::TableFieldKeyValue::new(k, v, span),
            )
        };
        __data_stack.__stack17.push(__res);
        Ok(true)
    }
    ///Field -> ident equal Exp
    #[inline]
    fn reduce_Field_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack17);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = ident.span().merge_ordered(&Exp.span());
            expression::TableField::NameValue(
                expression::TableFieldNameValue::new(ident.into(), Exp, span),
            )
        };
        __data_stack.__stack17.push(__res);
        Ok(true)
    }
    ///Field -> Exp
    #[inline]
    fn reduce_Field_2(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack17);
        let mut Exp = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            expression::TableField::Value(expression::TableFieldValue::new(Exp))
        };
        __data_stack.__stack17.push(__res);
        Ok(true)
    }
    ///FunctionDef -> function_ FuncBody
    #[inline]
    fn reduce_FunctionDef_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack18)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack18);
        let mut FuncBody = __data_stack.__stack18.pop().unwrap();
        let mut function_ = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            let span = function_.span().merge_ordered(&FuncBody.span());
            FuncBody.span = span;
            FuncBody
        };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///FuncBody -> lparen ParList? rparen Block end_
    #[inline]
    fn reduce_FuncBody_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 3usize) == Some(&
                ChunkOrExpressionsTags::__stack28)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 4usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 5usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack18);
        let mut ParList = __data_stack.__stack28.pop().unwrap();
        let mut Block = __data_stack.__stack3.pop().unwrap();
        let mut end_ = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        let mut lparen = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 5usize);
        let __res = {
            let span = lparen.span().merge_ordered(&end_.span());
            expression::ExprFunction::new(ParList, Block, span)
        };
        __data_stack.__stack18.push(__res);
        Ok(true)
    }
    ///FuncName1 -> FuncName1 dot ident
    #[inline]
    fn reduce_FuncName1_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack11)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut FuncName1 = __data_stack.__stack11.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            FuncName1.push(ident.into());
            FuncName1
        };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///FuncName1 -> ident
    #[inline]
    fn reduce_FuncName1_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack11);
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![ident.into()] };
        __data_stack.__stack11.push(__res);
        Ok(true)
    }
    ///FuncName -> FuncName1 colon ident
    #[inline]
    fn reduce_FuncName_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack11)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 3usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack19);
        let mut FuncName1 = __data_stack.__stack11.pop().unwrap();
        let mut ident = __data_stack.__terminals.pop().unwrap();
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            let span = FuncName1.first().unwrap().span().merge_ordered(&ident.span());
            statement::FunctionName::new(FuncName1, Some(ident.into()), span)
        };
        __data_stack.__stack19.push(__res);
        Ok(true)
    }
    ///FuncName -> FuncName1
    #[inline]
    fn reduce_FuncName_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack11)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack19);
        let mut FuncName1 = __data_stack.__stack11.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            let span = FuncName1
                .first()
                .unwrap()
                .span()
                .merge_ordered(&FuncName1.last().unwrap().span());
            statement::FunctionName::new(FuncName1, None, span)
        };
        __data_stack.__stack19.push(__res);
        Ok(true)
    }
    ///ParList -> NameList (comma, dotdotdot)?
    #[inline]
    fn reduce_ParList_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack27)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack11)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack20);
        let mut NameList = __data_stack.__stack11.pop().unwrap();
        let mut var = __data_stack.__stack27.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            if let Some(var) = var {
                let span = NameList.first().unwrap().span().merge_ordered(&var.span());
                expression::ParameterList::new(NameList, true, span)
            } else {
                let span = NameList.first().unwrap().span();
                expression::ParameterList::new(NameList, false, span)
            }
        };
        __data_stack.__stack20.push(__res);
        Ok(true)
    }
    ///ParList -> dotdotdot
    #[inline]
    fn reduce_ParList_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack20);
        let mut dotdotdot = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = {
            expression::ParameterList::new(Vec::new(), true, dotdotdot.span())
        };
        __data_stack.__stack20.push(__res);
        Ok(true)
    }
    ///Statement+ -> Statement
    #[inline]
    fn reduce__StatementPlus27_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack4)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack21);
        let mut A = __data_stack.__stack4.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack21.push(__res);
        Ok(true)
    }
    ///Statement+ -> Statement+ Statement
    #[inline]
    fn reduce__StatementPlus27_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack4)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack21)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack21.pop().unwrap();
        let mut A = __data_stack.__stack4.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack21.push(__res);
        Ok(true)
    }
    ///Statement* -> Statement+
    #[inline(always)]
    fn reduce__StatementStar28_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __location_stack.truncate(__location_stack.len() - 1usize);
        true
    }
    ///Statement* ->
    #[inline]
    fn reduce__StatementStar28_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack21);
        let __res = { vec![] };
        __data_stack.__stack21.push(__res);
        Ok(true)
    }
    ///ReturnStatement? -> ReturnStatement
    #[inline]
    fn reduce__ReturnStatementQuestion29_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack6)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack22);
        let mut A = __data_stack.__stack6.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack22.push(__res);
        Ok(true)
    }
    ///ReturnStatement? ->
    #[inline]
    fn reduce__ReturnStatementQuestion29_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack22);
        let __res = { None };
        __data_stack.__stack22.push(__res);
        Ok(true)
    }
    ///ElseIf+ -> ElseIf
    #[inline]
    fn reduce__ElseIfPlus30_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack5)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack23);
        let mut A = __data_stack.__stack5.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![A] };
        __data_stack.__stack23.push(__res);
        Ok(true)
    }
    ///ElseIf+ -> ElseIf+ ElseIf
    #[inline]
    fn reduce__ElseIfPlus30_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack5)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::__stack23)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        let mut Ap = __data_stack.__stack23.pop().unwrap();
        let mut A = __data_stack.__stack5.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 2usize);
        let __res = {
            Ap.push(A);
            Ap
        };
        __data_stack.__stack23.push(__res);
        Ok(true)
    }
    ///ElseIf* -> ElseIf+
    #[inline(always)]
    fn reduce__ElseIfStar31_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __location_stack.truncate(__location_stack.len() - 1usize);
        true
    }
    ///ElseIf* ->
    #[inline]
    fn reduce__ElseIfStar31_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack23);
        let __res = { vec![] };
        __data_stack.__stack23.push(__res);
        Ok(true)
    }
    ///(else_, Block) -> else_ Block
    #[inline(always)]
    fn reduce__Group32_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack3);
        true
    }
    ///(else_, Block)? -> (else_, Block)
    #[inline]
    fn reduce___Group32Question33_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack3)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack24);
        let mut A = __data_stack.__stack3.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack24.push(__res);
        Ok(true)
    }
    ///(else_, Block)? ->
    #[inline]
    fn reduce___Group32Question33_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack24);
        let __res = { None };
        __data_stack.__stack24.push(__res);
        Ok(true)
    }
    ///(comma, Exp) -> comma Exp
    #[inline(always)]
    fn reduce__Group34_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack7);
        true
    }
    ///(comma, Exp)? -> (comma, Exp)
    #[inline]
    fn reduce___Group34Question35_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack7)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack25);
        let mut A = __data_stack.__stack7.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///(comma, Exp)? ->
    #[inline]
    fn reduce___Group34Question35_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack25);
        let __res = { None };
        __data_stack.__stack25.push(__res);
        Ok(true)
    }
    ///(equal, ExpList1) -> equal ExpList1
    #[inline(always)]
    fn reduce__Group36_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __location_stack.truncate(__location_stack.len() - 2usize);
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack10);
        true
    }
    ///(equal, ExpList1)? -> (equal, ExpList1)
    #[inline]
    fn reduce___Group36Question37_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack10)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack26);
        let mut A = __data_stack.__stack10.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack26.push(__res);
        Ok(true)
    }
    ///(equal, ExpList1)? ->
    #[inline]
    fn reduce___Group36Question37_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack26);
        let __res = { None };
        __data_stack.__stack26.push(__res);
        Ok(true)
    }
    ///semicolon? -> semicolon
    #[inline]
    fn reduce__semicolonQuestion38_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack27);
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
    ///semicolon? ->
    #[inline]
    fn reduce__semicolonQuestion38_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack27);
        let __res = { None };
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
    ///$sep(Field, FieldSep, +) -> Field
    #[inline]
    fn reduce__FieldSepPlus39_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack17)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack16);
        let mut __token0 = __data_stack.__stack17.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = { vec![__token0] };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///$sep(Field, FieldSep, +) -> $sep(Field, FieldSep, +) FieldSep Field
    #[inline]
    fn reduce__FieldSepPlus39_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack17)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 1usize) == Some(&
                ChunkOrExpressionsTags::Empty)
            );
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 2usize) == Some(&
                ChunkOrExpressionsTags::__stack16)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 2usize);
        let mut __token0 = __data_stack.__stack16.pop().unwrap();
        let mut __token1 = __data_stack.__stack17.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 3usize);
        let __res = {
            __token0.push(__token1);
            __token0
        };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///$sep(Field, FieldSep, *) -> $sep(Field, FieldSep, +)
    #[inline(always)]
    fn reduce__FieldSepStar40_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        __location_stack.truncate(__location_stack.len() - 1usize);
        true
    }
    ///$sep(Field, FieldSep, *) ->
    #[inline]
    fn reduce__FieldSepStar40_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack16);
        let __res = { vec![] };
        __data_stack.__stack16.push(__res);
        Ok(true)
    }
    ///ParList? -> ParList
    #[inline]
    fn reduce__ParListQuestion41_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__stack20)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack28);
        let mut A = __data_stack.__stack20.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack28.push(__res);
        Ok(true)
    }
    ///ParList? ->
    #[inline]
    fn reduce__ParListQuestion41_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack28);
        let __res = { None };
        __data_stack.__stack28.push(__res);
        Ok(true)
    }
    ///(comma, dotdotdot) -> comma dotdotdot
    #[inline(always)]
    fn reduce__Group42_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
    ) -> bool {
        let __ret = __data_stack
            .__terminals
            .swap_remove(__data_stack.__terminals.len() - 1 - 0usize);
        __data_stack.__terminals.truncate(__data_stack.__terminals.len() - 1usize);
        __data_stack.__terminals.push(__ret);
        __location_stack.truncate(__location_stack.len() - 2usize);
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        true
    }
    ///(comma, dotdotdot)? -> (comma, dotdotdot)
    #[inline]
    fn reduce___Group42Question43_0(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)]
        {
            debug_assert!(
                __data_stack.__tags.get(__data_stack.__tags.len() - 1 - 0usize) == Some(&
                ChunkOrExpressionsTags::__terminals)
            );
        }
        __data_stack.__tags.truncate(__data_stack.__tags.len() - 1usize);
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack27);
        let mut A = __data_stack.__terminals.pop().unwrap();
        __location_stack.truncate(__location_stack.len() - 1usize);
        let __res = Some(A);
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
    ///(comma, dotdotdot)? ->
    #[inline]
    fn reduce___Group42Question43_1(
        __data_stack: &mut Self,
        __location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Token>,
        data: &mut (),
        __rustylr_location0: &mut ::rusty_lr::DefaultLocation,
    ) -> Result<bool, ParseError> {
        #[cfg(debug_assertions)] {}
        __data_stack.__tags.push(ChunkOrExpressionsTags::__stack27);
        let __res = { None };
        __data_stack.__stack27.push(__res);
        Ok(true)
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr::parser::data_stack::DataStack for ChunkOrExpressionsDataStack {
    type Term = Token;
    type NonTerm = ChunkOrExpressionsNonTerminals;
    type ReduceActionError = ParseError;
    type UserData = ();
    type StartType = ChunkOrExpressions;
    type Location = ::rusty_lr::DefaultLocation;
    fn pop_start(&mut self) -> Option<Self::StartType> {
        let tag = self.__tags.pop();
        debug_assert!(tag == Some(ChunkOrExpressionsTags::__stack2));
        self.__stack2.pop()
    }
    fn pop(&mut self) {
        match self.__tags.pop().unwrap() {
            ChunkOrExpressionsTags::__terminals => {
                self.__terminals.pop();
            }
            ChunkOrExpressionsTags::__stack2 => {
                self.__stack2.pop();
            }
            ChunkOrExpressionsTags::__stack3 => {
                self.__stack3.pop();
            }
            ChunkOrExpressionsTags::__stack4 => {
                self.__stack4.pop();
            }
            ChunkOrExpressionsTags::__stack5 => {
                self.__stack5.pop();
            }
            ChunkOrExpressionsTags::__stack6 => {
                self.__stack6.pop();
            }
            ChunkOrExpressionsTags::__stack7 => {
                self.__stack7.pop();
            }
            ChunkOrExpressionsTags::__stack8 => {
                self.__stack8.pop();
            }
            ChunkOrExpressionsTags::__stack9 => {
                self.__stack9.pop();
            }
            ChunkOrExpressionsTags::__stack10 => {
                self.__stack10.pop();
            }
            ChunkOrExpressionsTags::__stack11 => {
                self.__stack11.pop();
            }
            ChunkOrExpressionsTags::__stack12 => {
                self.__stack12.pop();
            }
            ChunkOrExpressionsTags::__stack13 => {
                self.__stack13.pop();
            }
            ChunkOrExpressionsTags::__stack14 => {
                self.__stack14.pop();
            }
            ChunkOrExpressionsTags::__stack15 => {
                self.__stack15.pop();
            }
            ChunkOrExpressionsTags::__stack16 => {
                self.__stack16.pop();
            }
            ChunkOrExpressionsTags::__stack17 => {
                self.__stack17.pop();
            }
            ChunkOrExpressionsTags::__stack18 => {
                self.__stack18.pop();
            }
            ChunkOrExpressionsTags::__stack19 => {
                self.__stack19.pop();
            }
            ChunkOrExpressionsTags::__stack20 => {
                self.__stack20.pop();
            }
            ChunkOrExpressionsTags::__stack21 => {
                self.__stack21.pop();
            }
            ChunkOrExpressionsTags::__stack22 => {
                self.__stack22.pop();
            }
            ChunkOrExpressionsTags::__stack23 => {
                self.__stack23.pop();
            }
            ChunkOrExpressionsTags::__stack24 => {
                self.__stack24.pop();
            }
            ChunkOrExpressionsTags::__stack25 => {
                self.__stack25.pop();
            }
            ChunkOrExpressionsTags::__stack26 => {
                self.__stack26.pop();
            }
            ChunkOrExpressionsTags::__stack27 => {
                self.__stack27.pop();
            }
            ChunkOrExpressionsTags::__stack28 => {
                self.__stack28.pop();
            }
            _ => {}
        }
    }
    fn push_terminal(&mut self, term: Self::Term) {
        self.__tags.push(ChunkOrExpressionsTags::__terminals);
        self.__terminals.push(term);
    }
    fn push_empty(&mut self) {
        self.__tags.push(ChunkOrExpressionsTags::Empty);
    }
    fn clear(&mut self) {
        self.__tags.clear();
        self.__terminals.clear();
        self.__stack2.clear();
        self.__stack3.clear();
        self.__stack4.clear();
        self.__stack5.clear();
        self.__stack6.clear();
        self.__stack7.clear();
        self.__stack8.clear();
        self.__stack9.clear();
        self.__stack10.clear();
        self.__stack11.clear();
        self.__stack12.clear();
        self.__stack13.clear();
        self.__stack14.clear();
        self.__stack15.clear();
        self.__stack16.clear();
        self.__stack17.clear();
        self.__stack18.clear();
        self.__stack19.clear();
        self.__stack20.clear();
        self.__stack21.clear();
        self.__stack22.clear();
        self.__stack23.clear();
        self.__stack24.clear();
        self.__stack25.clear();
        self.__stack26.clear();
        self.__stack27.clear();
        self.__stack28.clear();
    }
    fn reserve(&mut self, additional: usize) {
        self.__tags.reserve(additional);
    }
    fn split_off(&mut self, at: usize) -> Self {
        let __other_tag_stack = self.__tags.split_off(at);
        let mut __counts: [u8; 28usize + 1] = [0; 28usize + 1];
        for &tag in &__other_tag_stack {
            __counts[tag as usize] += 1;
        }
        let __other___terminals = self
            .__terminals
            .split_off(self.__terminals.len() - (__counts[0usize] as usize));
        let __other___stack2 = self
            .__stack2
            .split_off(self.__stack2.len() - (__counts[1usize] as usize));
        let __other___stack3 = self
            .__stack3
            .split_off(self.__stack3.len() - (__counts[2usize] as usize));
        let __other___stack4 = self
            .__stack4
            .split_off(self.__stack4.len() - (__counts[3usize] as usize));
        let __other___stack5 = self
            .__stack5
            .split_off(self.__stack5.len() - (__counts[4usize] as usize));
        let __other___stack6 = self
            .__stack6
            .split_off(self.__stack6.len() - (__counts[5usize] as usize));
        let __other___stack7 = self
            .__stack7
            .split_off(self.__stack7.len() - (__counts[6usize] as usize));
        let __other___stack8 = self
            .__stack8
            .split_off(self.__stack8.len() - (__counts[7usize] as usize));
        let __other___stack9 = self
            .__stack9
            .split_off(self.__stack9.len() - (__counts[8usize] as usize));
        let __other___stack10 = self
            .__stack10
            .split_off(self.__stack10.len() - (__counts[9usize] as usize));
        let __other___stack11 = self
            .__stack11
            .split_off(self.__stack11.len() - (__counts[10usize] as usize));
        let __other___stack12 = self
            .__stack12
            .split_off(self.__stack12.len() - (__counts[11usize] as usize));
        let __other___stack13 = self
            .__stack13
            .split_off(self.__stack13.len() - (__counts[12usize] as usize));
        let __other___stack14 = self
            .__stack14
            .split_off(self.__stack14.len() - (__counts[13usize] as usize));
        let __other___stack15 = self
            .__stack15
            .split_off(self.__stack15.len() - (__counts[14usize] as usize));
        let __other___stack16 = self
            .__stack16
            .split_off(self.__stack16.len() - (__counts[15usize] as usize));
        let __other___stack17 = self
            .__stack17
            .split_off(self.__stack17.len() - (__counts[16usize] as usize));
        let __other___stack18 = self
            .__stack18
            .split_off(self.__stack18.len() - (__counts[17usize] as usize));
        let __other___stack19 = self
            .__stack19
            .split_off(self.__stack19.len() - (__counts[18usize] as usize));
        let __other___stack20 = self
            .__stack20
            .split_off(self.__stack20.len() - (__counts[19usize] as usize));
        let __other___stack21 = self
            .__stack21
            .split_off(self.__stack21.len() - (__counts[20usize] as usize));
        let __other___stack22 = self
            .__stack22
            .split_off(self.__stack22.len() - (__counts[21usize] as usize));
        let __other___stack23 = self
            .__stack23
            .split_off(self.__stack23.len() - (__counts[22usize] as usize));
        let __other___stack24 = self
            .__stack24
            .split_off(self.__stack24.len() - (__counts[23usize] as usize));
        let __other___stack25 = self
            .__stack25
            .split_off(self.__stack25.len() - (__counts[24usize] as usize));
        let __other___stack26 = self
            .__stack26
            .split_off(self.__stack26.len() - (__counts[25usize] as usize));
        let __other___stack27 = self
            .__stack27
            .split_off(self.__stack27.len() - (__counts[26usize] as usize));
        let __other___stack28 = self
            .__stack28
            .split_off(self.__stack28.len() - (__counts[27usize] as usize));
        Self {
            __tags: __other_tag_stack,
            __terminals: __other___terminals,
            __stack2: __other___stack2,
            __stack3: __other___stack3,
            __stack4: __other___stack4,
            __stack5: __other___stack5,
            __stack6: __other___stack6,
            __stack7: __other___stack7,
            __stack8: __other___stack8,
            __stack9: __other___stack9,
            __stack10: __other___stack10,
            __stack11: __other___stack11,
            __stack12: __other___stack12,
            __stack13: __other___stack13,
            __stack14: __other___stack14,
            __stack15: __other___stack15,
            __stack16: __other___stack16,
            __stack17: __other___stack17,
            __stack18: __other___stack18,
            __stack19: __other___stack19,
            __stack20: __other___stack20,
            __stack21: __other___stack21,
            __stack22: __other___stack22,
            __stack23: __other___stack23,
            __stack24: __other___stack24,
            __stack25: __other___stack25,
            __stack26: __other___stack26,
            __stack27: __other___stack27,
            __stack28: __other___stack28,
        }
    }
    fn append(&mut self, other: &mut Self) {
        self.__tags.append(&mut other.__tags);
        self.__terminals.append(&mut other.__terminals);
        self.__stack2.append(&mut other.__stack2);
        self.__stack3.append(&mut other.__stack3);
        self.__stack4.append(&mut other.__stack4);
        self.__stack5.append(&mut other.__stack5);
        self.__stack6.append(&mut other.__stack6);
        self.__stack7.append(&mut other.__stack7);
        self.__stack8.append(&mut other.__stack8);
        self.__stack9.append(&mut other.__stack9);
        self.__stack10.append(&mut other.__stack10);
        self.__stack11.append(&mut other.__stack11);
        self.__stack12.append(&mut other.__stack12);
        self.__stack13.append(&mut other.__stack13);
        self.__stack14.append(&mut other.__stack14);
        self.__stack15.append(&mut other.__stack15);
        self.__stack16.append(&mut other.__stack16);
        self.__stack17.append(&mut other.__stack17);
        self.__stack18.append(&mut other.__stack18);
        self.__stack19.append(&mut other.__stack19);
        self.__stack20.append(&mut other.__stack20);
        self.__stack21.append(&mut other.__stack21);
        self.__stack22.append(&mut other.__stack22);
        self.__stack23.append(&mut other.__stack23);
        self.__stack24.append(&mut other.__stack24);
        self.__stack25.append(&mut other.__stack25);
        self.__stack26.append(&mut other.__stack26);
        self.__stack27.append(&mut other.__stack27);
        self.__stack28.append(&mut other.__stack28);
    }
    fn reduce_action(
        data_stack: &mut Self,
        location_stack: &mut Vec<::rusty_lr::DefaultLocation>,
        rule_index: usize,
        shift: &mut bool,
        lookahead: &::rusty_lr::TerminalSymbol<Self::Term>,
        user_data: &mut Self::UserData,
        location0: &mut Self::Location,
    ) -> Result<bool, Self::ReduceActionError> {
        match rule_index {
            0usize => {
                Self::reduce_ChunkOrExpressions_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            1usize => {
                Self::reduce_ChunkOrExpressions_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            2usize => {
                unreachable!("{rule_index}: this production rule was optimized out")
            }
            3usize => {
                Self::reduce_Block_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            4usize => {
                Self::reduce_Statement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            5usize => {
                Self::reduce_Statement_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            6usize => {
                Self::reduce_Statement_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            7usize => {
                Self::reduce_Statement_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            8usize => {
                Self::reduce_Statement_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            9usize => {
                Self::reduce_Statement_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            10usize => {
                Self::reduce_Statement_6(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            11usize => {
                Self::reduce_Statement_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            12usize => {
                Self::reduce_Statement_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            13usize => {
                Self::reduce_Statement_9(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            14usize => {
                Self::reduce_Statement_10(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            15usize => {
                Self::reduce_Statement_11(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            16usize => {
                Self::reduce_Statement_12(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            17usize => {
                Self::reduce_Statement_13(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            18usize => {
                Self::reduce_Statement_14(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            19usize => {
                Self::reduce_ElseIf_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            20usize => {
                Self::reduce_ReturnStatement_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            21usize => {
                Self::reduce_Var_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            22usize => {
                Self::reduce_Var_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            23usize => {
                Self::reduce_Var_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            24usize => Ok(Self::reduce_PrefixExp_0(data_stack, location_stack)),
            25usize => {
                Self::reduce_PrefixExp_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            26usize => Ok(Self::reduce_PrefixExp_2(data_stack, location_stack)),
            27usize => {
                Self::reduce_FunctionCall_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            28usize => {
                Self::reduce_FunctionCall_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            29usize => {
                Self::reduce_Args_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            30usize => {
                Self::reduce_Args_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            31usize => {
                Self::reduce_Args_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            32usize => {
                Self::reduce_VarList_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            33usize => {
                Self::reduce_VarList_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            34usize => {
                Self::reduce_ExpList1_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            35usize => {
                Self::reduce_ExpList1_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            36usize => {
                Self::reduce_ExpList0_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            37usize => {
                Self::reduce_ExpList0_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            38usize => {
                Self::reduce_NameList_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            39usize => {
                Self::reduce_NameList_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            40usize => {
                Self::reduce_AttName_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            41usize => {
                Self::reduce_AttNameList_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            42usize => {
                Self::reduce_AttNameList_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            43usize => {
                Self::reduce_Attrib_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            44usize => {
                Self::reduce_Attrib_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            45usize => {
                Self::reduce_Exp_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            46usize => {
                Self::reduce_Exp_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            47usize => {
                Self::reduce_Exp_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            48usize => {
                Self::reduce_Exp_3(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            49usize => {
                Self::reduce_Exp_4(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            50usize => {
                Self::reduce_Exp_5(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            51usize => Ok(Self::reduce_Exp_6(data_stack, location_stack)),
            52usize => {
                Self::reduce_Exp_7(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            53usize => {
                Self::reduce_Exp_8(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            54usize => {
                Self::reduce_Exp_9(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            55usize => {
                Self::reduce_Exp_10(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            56usize => {
                Self::reduce_Exp_11(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            57usize => {
                Self::reduce_Exp_12(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            58usize => {
                Self::reduce_Exp_13(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            59usize => {
                Self::reduce_Exp_14(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            60usize => {
                Self::reduce_Exp_15(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            61usize => {
                Self::reduce_Exp_16(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            62usize => {
                Self::reduce_Exp_17(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            63usize => {
                Self::reduce_Exp_18(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            64usize => {
                Self::reduce_Exp_19(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            65usize => {
                Self::reduce_Exp_20(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            66usize => {
                Self::reduce_Exp_21(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            67usize => {
                Self::reduce_Exp_22(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            68usize => {
                Self::reduce_Exp_23(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            69usize => {
                Self::reduce_Exp_24(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            70usize => {
                Self::reduce_Exp_25(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            71usize => {
                Self::reduce_Exp_26(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            72usize => {
                Self::reduce_Exp_27(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            73usize => {
                Self::reduce_Exp_28(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            74usize => {
                Self::reduce_Exp_29(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            75usize => {
                Self::reduce_Exp_30(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            76usize => {
                Self::reduce_Exp_31(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            77usize => {
                Self::reduce_Exp_32(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            78usize => {
                Self::reduce_Exp_33(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            79usize => {
                Self::reduce_TableConstructor_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            80usize => {
                unreachable!("{rule_index}: this production rule was optimized out")
            }
            81usize => {
                Self::reduce_Field_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            82usize => {
                Self::reduce_Field_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            83usize => {
                Self::reduce_Field_2(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            84usize => {
                unreachable!("{rule_index}: this production rule was optimized out")
            }
            85usize => {
                unreachable!("{rule_index}: this production rule was optimized out")
            }
            86usize => {
                Self::reduce_FunctionDef_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            87usize => {
                Self::reduce_FuncBody_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            88usize => {
                Self::reduce_FuncName1_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            89usize => {
                Self::reduce_FuncName1_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            90usize => {
                Self::reduce_FuncName_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            91usize => {
                Self::reduce_FuncName_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            92usize => {
                Self::reduce_ParList_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            93usize => {
                Self::reduce_ParList_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            94usize => {
                Self::reduce__StatementPlus27_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            95usize => {
                Self::reduce__StatementPlus27_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            96usize => Ok(Self::reduce__StatementStar28_0(data_stack, location_stack)),
            97usize => {
                Self::reduce__StatementStar28_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            98usize => {
                Self::reduce__ReturnStatementQuestion29_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            99usize => {
                Self::reduce__ReturnStatementQuestion29_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            100usize => {
                Self::reduce__ElseIfPlus30_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            101usize => {
                Self::reduce__ElseIfPlus30_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            102usize => Ok(Self::reduce__ElseIfStar31_0(data_stack, location_stack)),
            103usize => {
                Self::reduce__ElseIfStar31_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            104usize => Ok(Self::reduce__Group32_0(data_stack, location_stack)),
            105usize => {
                Self::reduce___Group32Question33_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            106usize => {
                Self::reduce___Group32Question33_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            107usize => Ok(Self::reduce__Group34_0(data_stack, location_stack)),
            108usize => {
                Self::reduce___Group34Question35_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            109usize => {
                Self::reduce___Group34Question35_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            110usize => Ok(Self::reduce__Group36_0(data_stack, location_stack)),
            111usize => {
                Self::reduce___Group36Question37_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            112usize => {
                Self::reduce___Group36Question37_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            113usize => {
                Self::reduce__semicolonQuestion38_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            114usize => {
                Self::reduce__semicolonQuestion38_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            115usize => {
                Self::reduce__FieldSepPlus39_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            116usize => {
                Self::reduce__FieldSepPlus39_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            117usize => Ok(Self::reduce__FieldSepStar40_0(data_stack, location_stack)),
            118usize => {
                Self::reduce__FieldSepStar40_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            119usize => {
                Self::reduce__ParListQuestion41_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            120usize => {
                Self::reduce__ParListQuestion41_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            121usize => Ok(Self::reduce__Group42_0(data_stack, location_stack)),
            122usize => {
                Self::reduce___Group42Question43_0(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            123usize => {
                Self::reduce___Group42Question43_1(
                    data_stack,
                    location_stack,
                    shift,
                    lookahead,
                    user_data,
                    location0,
                )
            }
            124usize => {
                unreachable!("{rule_index}: this production rule was optimized out")
            }
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
}
/// A struct that holds the entire parser table and production rules.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
pub struct ChunkOrExpressionsParser {
    /// production rules
    pub rules: Vec<ChunkOrExpressionsRule>,
    /// states
    pub states: Vec<ChunkOrExpressionsState>,
    /// terminal classes
    pub classes: Vec<Vec<&'static str>>,
}
impl ::rusty_lr::parser::Parser for ChunkOrExpressionsParser {
    type Term = Token;
    type NonTerm = ChunkOrExpressionsNonTerminals;
    type State = ChunkOrExpressionsState;
    type TerminalClassElement = &'static str;
    const ERROR_USED: bool = false;
    fn class_precedence(
        &self,
        class: ::rusty_lr::TerminalSymbol<usize>,
    ) -> ::rusty_lr::parser::Precedence {
        match class {
            ::rusty_lr::TerminalSymbol::Term(class) => {
                #[allow(unreachable_patterns)]
                match class {
                    51 => ::rusty_lr::parser::Precedence::new(0),
                    38 => ::rusty_lr::parser::Precedence::new(1),
                    18..=23 => ::rusty_lr::parser::Precedence::new(2),
                    14 => ::rusty_lr::parser::Precedence::new(3),
                    13 => ::rusty_lr::parser::Precedence::new(4),
                    12 => ::rusty_lr::parser::Precedence::new(5),
                    15..=16 => ::rusty_lr::parser::Precedence::new(6),
                    36 => ::rusty_lr::parser::Precedence::new(7),
                    5..=6 => ::rusty_lr::parser::Precedence::new(8),
                    7..=9 | 17 => ::rusty_lr::parser::Precedence::new(9),
                    10 => ::rusty_lr::parser::Precedence::new(10),
                    _ => ::rusty_lr::parser::Precedence::none(),
                }
            }
            ::rusty_lr::TerminalSymbol::Error => ::rusty_lr::parser::Precedence::none(),
            ::rusty_lr::TerminalSymbol::Eof => {
                unreachable!("eof token cannot be used in precedence levels")
            }
        }
    }
    fn precedence_types(&self, level: u8) -> Option<::rusty_lr::rule::ReduceType> {
        #[allow(unreachable_patterns)]
        match level {
            0..=6 | 8..=9 => Some(::rusty_lr::rule::ReduceType::Left),
            7 | 10 => Some(::rusty_lr::rule::ReduceType::Right),
            _ => None,
        }
    }
    fn get_rules(&self) -> &[ChunkOrExpressionsRule] {
        &self.rules
    }
    fn get_states(&self) -> &[ChunkOrExpressionsState] {
        &self.states
    }
    fn get_terminals(
        &self,
        i: usize,
    ) -> Option<impl IntoIterator<Item = Self::TerminalClassElement> + '_> {
        self.classes.get(i).map(|class| class.iter().copied())
    }
    fn to_terminal_class(&self, terminal: &Self::Term) -> usize {
        #[allow(unreachable_patterns)]
        match filter(terminal) {
            TokenType::Ident(_) => 0,
            TokenType::String(_) => 1,
            TokenType::Numeric(_) => 2,
            TokenType::Nil => 3,
            TokenType::Bool(_) => 4,
            TokenType::Plus => 5,
            TokenType::Minus => 6,
            TokenType::Asterisk => 7,
            TokenType::Slash => 8,
            TokenType::Percent => 9,
            TokenType::Caret => 10,
            TokenType::Hash => 11,
            TokenType::Ampersand => 12,
            TokenType::Tilde => 13,
            TokenType::Pipe => 14,
            TokenType::LessLess => 15,
            TokenType::GreaterGreater => 16,
            TokenType::SlashSlash => 17,
            TokenType::EqualEqual => 18,
            TokenType::TildeEqual => 19,
            TokenType::LessEqual => 20,
            TokenType::GreaterEqual => 21,
            TokenType::Less => 22,
            TokenType::Greater => 23,
            TokenType::Equal => 24,
            TokenType::LParen => 25,
            TokenType::RParen => 26,
            TokenType::LBrace => 27,
            TokenType::RBrace => 28,
            TokenType::LBracket => 29,
            TokenType::RBracket => 30,
            TokenType::ColonColon => 31,
            TokenType::Semicolon => 32,
            TokenType::Colon => 33,
            TokenType::Comma => 34,
            TokenType::Dot => 35,
            TokenType::DotDot => 36,
            TokenType::DotDotDot => 37,
            TokenType::And => 38,
            TokenType::Break => 39,
            TokenType::Do => 40,
            TokenType::Else => 41,
            TokenType::Elseif => 42,
            TokenType::End => 43,
            TokenType::For => 44,
            TokenType::Function => 45,
            TokenType::Goto => 46,
            TokenType::If => 47,
            TokenType::In => 48,
            TokenType::Local => 49,
            TokenType::Not => 50,
            TokenType::Or => 51,
            TokenType::Repeat => 52,
            TokenType::Return => 53,
            TokenType::Then => 54,
            TokenType::Until => 55,
            TokenType::While => 56,
            _ => 57,
        }
    }
}
/// A struct that holds the whole parser table.
#[allow(unused_braces, unused_parens, unused_variables, non_snake_case, unused_mut)]
impl ChunkOrExpressionsParser {
    /// Calculates the states and parser tables from the grammar.
    #[allow(clippy::clone_on_copy)]
    pub fn new() -> Self {
        let rules: Vec<
            ::rusty_lr::rule::ProductionRule<::rusty_lr::TerminalSymbol<u8>, _>,
        > = vec![
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Chunk),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Chunk, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Block, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_StatementStar28),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion29),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(32)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::VarList),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(24)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FunctionCall),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(31)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(31)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(39)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(46)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(40)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(43)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(56)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(40)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(43)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(52)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(55)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(47)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(54)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ElseIfStar31),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group32Question33),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(43)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(44)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(24)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group34Question35),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(40)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(43)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(44)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(48)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(40)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(43)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(45)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(49)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(45)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Statement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(49)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttNameList),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group36Question37),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ElseIf, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(42)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(54)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ReturnStatement, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(53)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList0),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_semicolonQuestion38),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Var, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Var, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(29)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(30)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Var, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(35)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::PrefixExp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Var),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::PrefixExp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FunctionCall),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::PrefixExp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(25)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(26)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FunctionCall, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Args),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FunctionCall, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(33)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Args),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Args, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(25)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList0),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(26)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Args, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::TableConstructor),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Args, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(1)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::VarList, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::VarList),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Var),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::VarList, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Var),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ExpList1, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ExpList1, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ExpList0, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ExpList0, rule : vec![], precedence : None,
            }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::NameList, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::NameList, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::AttName, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Attrib),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::AttNameList, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttNameList),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttName),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::AttNameList, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttName),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Attrib, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(22)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(23)),], precedence :
            Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Attrib, rule : vec![], precedence : None, },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(2)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(3)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(1)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(4)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(37)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FunctionDef),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),],
            precedence : Some(::rusty_lr::rule::Precedence::Fixed(12usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::TableConstructor),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(50)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(11usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(11)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(11usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(6)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(11usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(5)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(11usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(13)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(11usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(7)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(9usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(8)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(9usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(17)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(9usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(9)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(9usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(5)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(8usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(6)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(8usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(36)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(7usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(15)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(6usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(16)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(6usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(12)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(5usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(13)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(4usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(14)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(3usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(22)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(20)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(23)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(21)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(19)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(18)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(2usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(38)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(1usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(51)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(0usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Exp, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(10)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : Some(::rusty_lr::rule::Precedence::Fixed(10usize)), },
            ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::TableConstructor, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(27)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldList),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(28)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FieldList, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_FieldSepStar40),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Field, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(29)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(30)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(24)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Field, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(24)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Field, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FieldSep, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FieldSep, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(32)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FunctionDef, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(45)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FuncBody, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(25)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ParListQuestion41),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(26)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(43)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FuncName1, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName1),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(35)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FuncName1, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FuncName, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName1),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(33)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(0)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::FuncName, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName1),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ParList, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group42Question43),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::ParList, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(37)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_StatementPlus27, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_StatementPlus27, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_StatementPlus27),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Statement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_StatementStar28, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_StatementPlus27),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_StatementStar28, rule : vec![], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion29, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ReturnStatement),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion29, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ElseIfPlus30, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ElseIf),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ElseIfPlus30, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ElseIfPlus30),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ElseIf),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ElseIfStar31, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ElseIfPlus30),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ElseIfStar31, rule : vec![], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_Group32, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(41)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group32Question33, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_Group32),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group32Question33, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_Group34, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group34Question35, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_Group34),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group34Question35, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_Group36, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(24)),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group36Question37, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_Group36),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group36Question37, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_semicolonQuestion38, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(32)),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_semicolonQuestion38, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_FieldSepPlus39, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Field),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_FieldSepPlus39, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_FieldSepPlus39),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldSep),
            ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Field),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_FieldSepStar40, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_FieldSepPlus39),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_FieldSepStar40, rule : vec![], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ParListQuestion41, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ParList),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_ParListQuestion41, rule : vec![], precedence
            : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::_Group42, rule :
            vec![::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(34)),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Term(37)),], precedence :
            None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group42Question43, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_Group42),],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::__Group42Question43, rule : vec![],
            precedence : None, }, ::rusty_lr::rule::ProductionRule { name :
            ChunkOrExpressionsNonTerminals::Augmented, rule :
            vec![::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ChunkOrExpressions),
            ::rusty_lr::Token::Term(::rusty_lr::TerminalSymbol::Eof),], precedence :
            None, },
        ];
        let terminal_class_names = vec![
            "ident", "string_literal", "numeric_literal", "nil", "bool_", "plus",
            "minus", "asterisk", "slash", "percent", "caret", "hash", "ampersand",
            "tilde", "pipe", "lessless", "greatergreater", "slashslash", "equalequal",
            "tildeequal", "lessequal", "greaterequal", "less", "greater", "equal",
            "lparen", "rparen", "lbrace", "rbrace", "lbracket", "rbracket", "coloncolon",
            "semicolon", "colon", "comma", "dot", "dotdot", "dotdotdot", "and_",
            "break_", "do_", "else_", "elseif_", "end_", "for_", "function_", "goto_",
            "if_", "in_", "local_", "not_", "or_", "repeat_", "return_", "then_",
            "until_", "while_", "<Others>",
        ];
        let rules = rules
            .into_iter()
            .map(move |rule| {
                rule.map(
                    |term| match term {
                        ::rusty_lr::TerminalSymbol::Term(term) => {
                            terminal_class_names[term as usize]
                        }
                        ::rusty_lr::TerminalSymbol::Error => "error",
                        ::rusty_lr::TerminalSymbol::Eof => "eof",
                    },
                    |nonterm| nonterm,
                )
            })
            .collect();
        let __rustylr_tset1: Vec<u8> = vec![
            0, 1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
            25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44,
            45, 46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset9: Vec<u8> = vec![
            0, 1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25,
            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 43, 44, 45,
            46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset2: Vec<u8> = vec![
            0, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26,
            28, 30, 31, 32, 34, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52,
            53, 54, 55, 56
        ];
        let __rustylr_tset11: Vec<u8> = vec![
            0, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 28,
            30, 31, 32, 34, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53,
            54, 55, 56
        ];
        let __rustylr_tset10: Vec<u8> = vec![
            0, 5, 6, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32,
            34, 36, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset13: Vec<u8> = vec![
            0, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34,
            38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset12: Vec<u8> = vec![
            0, 12, 13, 14, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39,
            40, 41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset14: Vec<u8> = vec![
            0, 13, 14, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40,
            41, 42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset15: Vec<u8> = vec![
            0, 14, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41,
            42, 43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset16: Vec<u8> = vec![
            0, 18, 19, 20, 21, 22, 23, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41, 42,
            43, 44, 45, 46, 47, 49, 51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset24: Vec<u8> = vec![
            0, 24, 25, 31, 32, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 55, 56
        ];
        let __rustylr_tset17: Vec<u8> = vec![
            0, 25, 26, 28, 30, 31, 32, 34, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49,
            51, 52, 53, 54, 55, 56
        ];
        let __rustylr_tset18: Vec<u8> = vec![
            0, 25, 26, 28, 30, 31, 32, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 51,
            52, 53, 54, 55, 56
        ];
        let __rustylr_tset30: Vec<u8> = vec![
            0, 25, 26, 31, 32, 34, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 55, 56
        ];
        let __rustylr_tset19: Vec<u8> = vec![
            0, 25, 31, 32, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 55, 56
        ];
        let __rustylr_tset31: Vec<u8> = vec![
            0, 31, 32, 39, 40, 41, 42, 43, 44, 45, 46, 47, 49, 52, 53, 55, 56
        ];
        let __rustylr_tset4: Vec<u8> = vec![
            1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 27,
            28, 29, 32, 33, 34, 35, 36, 38, 51
        ];
        let __rustylr_tset26: Vec<u8> = vec![
            1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 25, 27,
            29, 33, 35, 36, 38, 51
        ];
        let __rustylr_tset32: Vec<u8> = vec![
            1, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 27, 29,
            33, 34, 35, 36, 38, 51
        ];
        let __rustylr_tset33: Vec<u8> = vec![1, 25, 27, 29, 33, 35];
        let __rustylr_tset28: Vec<u8> = vec![24];
        let __rustylr_tset34: Vec<u8> = vec![24, 34];
        let __rustylr_tset22: Vec<u8> = vec![25];
        let __rustylr_tset21: Vec<u8> = vec![25, 33, 35];
        let __rustylr_tset5: Vec<u8> = vec![26];
        let __rustylr_tset29: Vec<u8> = vec![26, 32, 41, 42, 43, 55];
        let __rustylr_tset6: Vec<u8> = vec![26, 34];
        let __rustylr_tset7: Vec<u8> = vec![26, 34, 48];
        let __rustylr_tset3: Vec<u8> = vec![28];
        let __rustylr_tset23: Vec<u8> = vec![28, 32, 34];
        let __rustylr_tset37: Vec<u8> = vec![32, 41, 42, 43, 55];
        let __rustylr_tset27: Vec<u8> = vec![34];
        let __rustylr_tset20: Vec<u8> = vec![34, 48];
        let __rustylr_tset38: Vec<u8> = vec![40];
        let __rustylr_tset41: Vec<u8> = vec![41, 42, 43];
        let __rustylr_tset39: Vec<u8> = vec![41, 42, 43, 53];
        let __rustylr_tset35: Vec<u8> = vec![41, 42, 43, 53, 55];
        let __rustylr_tset36: Vec<u8> = vec![41, 42, 43, 55];
        let __rustylr_tset40: Vec<u8> = vec![41, 43];
        let __rustylr_tset42: Vec<u8> = vec![43];
        let __rustylr_tset8: Vec<u8> = vec![43, 53];
        let __rustylr_tset0: Vec<u8> = vec![53];
        let __rustylr_tset25: Vec<u8> = vec![53, 55];
        let states: Vec<::rusty_lr::parser::state::IntermediateState<u8, _, u8, u8>> = vec![
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(216, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::ChunkOrExpressions,
            ::rusty_lr::parser::state::ShiftTarget::new(217, true)),
            (ChunkOrExpressionsNonTerminals::Chunk,
            ::rusty_lr::parser::state::ShiftTarget::new(219, true)),
            (ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(219, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::ExpList1,
            ::rusty_lr::parser::state::ShiftTarget::new(220, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset0.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![97]), ruleset : { let rules : & 'static [u8] = &
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22,
            23, 24, 25, 26, 27, 28, 32, 33, 34, 35, 45, 46, 47, 48, 49, 50, 51, 52, 53,
            54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72,
            73, 74, 75, 76, 77, 78, 79, 86, 94, 95, 96, 97, 124,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![21]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![21]), ruleset : { let rules : & 'static [u8] = & [21,]; let shifted
            : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![47]; __reduce_map.extend(__rustylr_tset2.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![47]), ruleset : { let rules :
            & 'static [u8] = & [47,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![45]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![45]), ruleset : { let rules : & 'static [u8] = & [45,]; let shifted
            : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![46]; __reduce_map.extend(__rustylr_tset2.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![46]), ruleset : { let rules :
            & 'static [u8] = & [46,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![48]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![48]), ruleset : { let rules : & 'static [u8] = & [48,]; let shifted
            : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(157, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(156, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(155, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(154, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(33, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (29,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FieldList,
            ::rusty_lr::parser::state::ShiftTarget::new(101, true)),
            (ChunkOrExpressionsNonTerminals::Field,
            ::rusty_lr::parser::state::ShiftTarget::new(103, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),
            (ChunkOrExpressionsNonTerminals::_FieldSepPlus39,
            ::rusty_lr::parser::state::ShiftTarget::new(104, true)),
            (ChunkOrExpressionsNonTerminals::_FieldSepStar40,
            ::rusty_lr::parser::state::ShiftTarget::new(101, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![118]; __reduce_map.extend(__rustylr_tset3.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [21, 22,
            23, 24, 25, 26, 27, 28, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
            58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
            77, 78, 79, 79, 80, 81, 82, 83, 86, 115, 116, 117, 118,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(24, ::rusty_lr::parser::state::ShiftTarget::new(13, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![21]; __reduce_map.extend(__rustylr_tset4.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [21, 82,]; let shifted : & 'static [u8] = & [1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(215, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 82, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![49]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![49]), ruleset : { let rules : & 'static [u8] = & [49,]; let shifted
            : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(25, ::rusty_lr::parser::state::ShiftTarget::new(16, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::FuncBody,
            ::rusty_lr::parser::state::ShiftTarget::new(153, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [86, 87,]; let shifted : & 'static [u8] = &
            [1, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(17, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(18, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::NameList,
            ::rusty_lr::parser::state::ShiftTarget::new(19, true)),
            (ChunkOrExpressionsNonTerminals::ParList,
            ::rusty_lr::parser::state::ShiftTarget::new(25, true)),
            (ChunkOrExpressionsNonTerminals::_ParListQuestion41,
            ::rusty_lr::parser::state::ShiftTarget::new(26, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![120]; __reduce_map.extend(__rustylr_tset5.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [38, 39,
            87, 92, 93, 119, 120,]; let shifted : & 'static [u8] = & [0, 0, 1, 0, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![39]; __reduce_map
            .extend(__rustylr_tset6.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [39,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![93]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [93,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(34,
            ::rusty_lr::parser::state::ShiftTarget::new(20, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::_Group42,
            ::rusty_lr::parser::state::ShiftTarget::new(23, true)),
            (ChunkOrExpressionsNonTerminals::__Group42Question43,
            ::rusty_lr::parser::state::ShiftTarget::new(24, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![123]; __reduce_map.extend(__rustylr_tset5.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [38, 92,
            121, 122, 123,]; let shifted : & 'static [u8] = & [1, 1, 0, 0, 0,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(22, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [38, 121,]; let shifted : & 'static [u8] = & [2, 1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![38]; __reduce_map
            .extend(__rustylr_tset7.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [38,]; let shifted : & 'static
            [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![121]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [121,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![122]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [122,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![92]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [92,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![119]; __reduce_map
            .extend(__rustylr_tset5.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [119,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(26,
            ::rusty_lr::parser::state::ShiftTarget::new(27, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [87,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(121, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27,
            28, 32, 33, 87, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(145, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(1,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (29,
            ::rusty_lr::parser::state::ShiftTarget::new(132, true)), (33,
            ::rusty_lr::parser::state::ShiftTarget::new(138, true)), (35,
            ::rusty_lr::parser::state::ShiftTarget::new(142, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Args,
            ::rusty_lr::parser::state::ShiftTarget::new(144, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(141, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![51]; __reduce_map.extend(__rustylr_tset2.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![51]), ruleset : { let rules : & 'static [u8] = &
            [22, 23, 27, 28, 29, 30, 31, 51, 79,]; let shifted : & 'static [u8] = & [1,
            1, 1, 1, 0, 0, 0, 1, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![31]; __reduce_map.extend(__rustylr_tset9.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![31]), ruleset : { let rules :
            & 'static [u8] = & [31,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::ExpList1,
            ::rusty_lr::parser::state::ShiftTarget::new(126, true)),
            (ChunkOrExpressionsNonTerminals::ExpList0,
            ::rusty_lr::parser::state::ShiftTarget::new(129, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![37]; __reduce_map.extend(__rustylr_tset5.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [21, 22,
            23, 24, 25, 26, 27, 28, 29, 34, 35, 36, 37, 45, 46, 47, 48, 49, 50, 51, 52,
            53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
            72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : & 'static [u8] = & [0, 0,
            0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![25]; __reduce_map
            .extend(__rustylr_tset9.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![25]), ruleset : { let rules : & 'static [u8] = & [25,]; let shifted
            : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (26,
            ::rusty_lr::parser::state::ShiftTarget::new(74, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [26, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
            71, 72, 73, 74, 75, 76, 77, 78,]; let shifted : & 'static [u8] = & [2, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(35, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![62]; __reduce_map.extend(__rustylr_tset10.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![62]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 78,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 3,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(37, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![58]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![58]), ruleset : { let rules : & 'static [u8] = &
            [58, 78,]; let shifted : & 'static [u8] = & [3, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(39, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![78]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![78]), ruleset : { let rules : & 'static [u8] = &
            [78, 78,]; let shifted : & 'static [u8] = & [1, 3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![52]; __reduce_map.extend(__rustylr_tset2.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![52]), ruleset : { let rules :
            & 'static [u8] = & [52,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![50]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![50]), ruleset : { let rules : & 'static [u8] = & [50,]; let shifted
            : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(43, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![59]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![59]), ruleset : { let rules : & 'static [u8] = &
            [59, 78,]; let shifted : & 'static [u8] = & [3, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(45, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![61]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![61]), ruleset : { let rules : & 'static [u8] = &
            [61, 78,]; let shifted : & 'static [u8] = & [3, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(47, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![60]; __reduce_map.extend(__rustylr_tset11.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![60]), ruleset : { let rules : & 'static [u8] = &
            [60, 78,]; let shifted : & 'static [u8] = & [3, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(49, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![63]; __reduce_map.extend(__rustylr_tset10.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![63]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 63, 78,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 3,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(51, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![67]; __reduce_map.extend(__rustylr_tset12.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![67]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 78,]; let shifted : & 'static [u8] =
            & [1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(53, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![65]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![65]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 78,]; let shifted : & 'static [u8] = & [1,
            1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(55, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![64]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![64]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 64, 78,]; let shifted : & 'static [u8] = & [1,
            1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(57, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![66]; __reduce_map.extend(__rustylr_tset13.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![66]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 66, 78,]; let shifted : & 'static [u8] = & [1,
            1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(59, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![68]; __reduce_map.extend(__rustylr_tset14.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![68]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 78,]; let shifted : & 'static
            [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(61, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![69]; __reduce_map.extend(__rustylr_tset15.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![69]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 78,]; let shifted : &
            'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(63, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![75]; __reduce_map.extend(__rustylr_tset16.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![75]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 75, 78,]; let shifted : &
            'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(65, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![74]; __reduce_map.extend(__rustylr_tset16.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![74]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 74, 78,]; let shifted : &
            'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(67, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![71]; __reduce_map.extend(__rustylr_tset16.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![71]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 78,]; let shifted : &
            'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(69, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![73]; __reduce_map.extend(__rustylr_tset16.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![73]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 73, 78,]; let shifted : &
            'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(71, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![70]; __reduce_map.extend(__rustylr_tset16.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![70]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 78,]; let shifted : &
            'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(73, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![72]; __reduce_map.extend(__rustylr_tset16.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![72]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 72, 78,]; let shifted : &
            'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![26]; __reduce_map
            .extend(__rustylr_tset9.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![26]), ruleset : { let rules : & 'static [u8] = & [26,]; let shifted
            : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(76, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![76]; __reduce_map.extend(__rustylr_tset17.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![76]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
            78,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(78, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![77]; __reduce_map.extend(__rustylr_tset18.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![77]), ruleset : { let rules : & 'static [u8] = &
            [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76,
            77, 78,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 3, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(211, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 81, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(81, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [7,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(31,
            ::rusty_lr::parser::state::ShiftTarget::new(82, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [7,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![7]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![7]), ruleset : { let rules : & 'static [u8] = & [7,];
            let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![4]; __reduce_map.extend(__rustylr_tset19.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![4]), ruleset : { let rules : &
            'static [u8] = & [4,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![8]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![8]), ruleset : { let rules : & 'static [u8] = & [8,];
            let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(167, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26,
            27, 28, 32, 33, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(87, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::NameList,
            ::rusty_lr::parser::state::ShiftTarget::new(179, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [14, 15, 38, 39,]; let shifted : & 'static
            [u8] = & [1, 1, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(24, ::rusty_lr::parser::state::ShiftTarget::new(88, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![39]; __reduce_map.extend(__rustylr_tset20.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [14, 39,]; let shifted : & 'static [u8] = & [2, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(169, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [14, 21, 22, 23, 24, 25, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(90, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::FuncName1,
            ::rusty_lr::parser::state::ShiftTarget::new(91, true)),
            (ChunkOrExpressionsNonTerminals::FuncName,
            ::rusty_lr::parser::state::ShiftTarget::new(96, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [16, 88, 89, 90, 91,]; let shifted : & 'static
            [u8] = & [1, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![89]; __reduce_map.extend(__rustylr_tset21.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [89,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(33,
            ::rusty_lr::parser::state::ShiftTarget::new(92, true)), (35,
            ::rusty_lr::parser::state::ShiftTarget::new(94, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![91]; __reduce_map.extend(__rustylr_tset22.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [88, 90,
            91,]; let shifted : & 'static [u8] = & [1, 1, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(93, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [90,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![90]; __reduce_map
            .extend(__rustylr_tset22.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [90,]; let
            shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(95, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [88,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![88]; __reduce_map
            .extend(__rustylr_tset21.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [88,]; let
            shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(25, ::rusty_lr::parser::state::ShiftTarget::new(16, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::FuncBody,
            ::rusty_lr::parser::state::ShiftTarget::new(186, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [16, 87,]; let shifted : & 'static [u8] = &
            [2, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(98, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [9,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![9]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![9]), ruleset : { let rules : & 'static [u8] = & [9,];
            let shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(187, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [13, 21, 22, 23, 24, 25, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![83]; __reduce_map.extend(__rustylr_tset23.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [58, 59,
            60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
            83,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(28, ::rusty_lr::parser::state::ShiftTarget::new(102, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [79,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![79]; __reduce_map
            .extend(__rustylr_tset9.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![79]), ruleset : { let rules : & 'static [u8] = & [79,]; let shifted
            : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![115]; __reduce_map.extend(__rustylr_tset23.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [115,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(32,
            ::rusty_lr::parser::state::ShiftTarget::new(105, false)), (34,
            ::rusty_lr::parser::state::ShiftTarget::new(105, false)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::FieldSep,
            ::rusty_lr::parser::state::ShiftTarget::new(105, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![117]; __reduce_map.extend(__rustylr_tset3.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [84, 85,
            116, 117,]; let shifted : & 'static [u8] = & [0, 0, 1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(12, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (29,
            ::rusty_lr::parser::state::ShiftTarget::new(79, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(100, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::Field,
            ::rusty_lr::parser::state::ShiftTarget::new(106, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 81, 82, 83, 86, 116,];
            let shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![116]; __reduce_map.extend(__rustylr_tset23.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [116,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(108, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(113, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::AttName,
            ::rusty_lr::parser::state::ShiftTarget::new(116, true)),
            (ChunkOrExpressionsNonTerminals::AttNameList,
            ::rusty_lr::parser::state::ShiftTarget::new(117, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [17, 18, 40, 41, 42,]; let shifted : & 'static
            [u8] = & [1, 1, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(22, ::rusty_lr::parser::state::ShiftTarget::new(109, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Attrib,
            ::rusty_lr::parser::state::ShiftTarget::new(112, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![44]; __reduce_map.extend(__rustylr_tset24.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![44]), ruleset : { let rules : & 'static [u8] = &
            [40, 43, 44,]; let shifted : & 'static [u8] = & [1, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(110, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [43,]; let shifted : & 'static [u8] = & [1,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(23,
            ::rusty_lr::parser::state::ShiftTarget::new(111, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [43,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![43]; __reduce_map
            .extend(__rustylr_tset24.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![43]), ruleset : { let rules : & 'static [u8] = &
            [43,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![40]; __reduce_map.extend(__rustylr_tset24.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![40]), ruleset : { let rules :
            & 'static [u8] = & [40,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(114, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [17,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(25,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::FuncBody,
            ::rusty_lr::parser::state::ShiftTarget::new(115, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [17, 87,]; let shifted : & 'static [u8] = &
            [3, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![17]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![17]), ruleset : { let rules : & 'static [u8] = &
            [17,]; let shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![42]; __reduce_map.extend(__rustylr_tset24.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![42]), ruleset : { let rules :
            & 'static [u8] = & [42,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(24,
            ::rusty_lr::parser::state::ShiftTarget::new(118, true)), (34,
            ::rusty_lr::parser::state::ShiftTarget::new(190, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::_Group36,
            ::rusty_lr::parser::state::ShiftTarget::new(192, true)),
            (ChunkOrExpressionsNonTerminals::__Group36Question37,
            ::rusty_lr::parser::state::ShiftTarget::new(193, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![112]; __reduce_map.extend(__rustylr_tset19.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![112]), ruleset : { let rules : & 'static [u8] =
            & [18, 41, 110, 111, 112,]; let shifted : & 'static [u8] = & [2, 1, 0, 0,
            0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::ExpList1,
            ::rusty_lr::parser::state::ShiftTarget::new(189, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 34, 35, 45,
            46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86, 110,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted
            as usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(194, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset25.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26,
            27, 28, 32, 33, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(163, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [11, 21, 22, 23, 24, 25, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(43,
            ::rusty_lr::parser::state::ShiftTarget::new(122, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [87,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![87]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![87]), ruleset : { let rules : & 'static [u8] = & [87,]; let shifted
            : & 'static [u8] = & [5,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![94]; __reduce_map.extend(__rustylr_tset19.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![94]), ruleset : { let rules :
            & 'static [u8] = & [94,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![24]; __reduce_map
            .extend(__rustylr_tset26.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![24, 33]; __reduce_map
            .extend(__rustylr_tset27.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![33]; __reduce_map
            .extend(__rustylr_tset28.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![24]), ruleset : { let rules : & 'static [u8] = & [24,
            33,]; let shifted : & 'static [u8] = & [1, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(1,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (29,
            ::rusty_lr::parser::state::ShiftTarget::new(132, true)), (33,
            ::rusty_lr::parser::state::ShiftTarget::new(138, true)), (35,
            ::rusty_lr::parser::state::ShiftTarget::new(142, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Args,
            ::rusty_lr::parser::state::ShiftTarget::new(144, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(141, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [22, 23, 27, 28, 29, 30, 31, 79,]; let shifted
            : & 'static [u8] = & [1, 1, 1, 1, 0, 0, 0, 0,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(34, ::rusty_lr::parser::state::ShiftTarget::new(127, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![36]; __reduce_map.extend(__rustylr_tset29.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![36]), ruleset : { let rules :
            & 'static [u8] = & [34, 36,]; let shifted : & 'static [u8] = & [1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(128, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 34, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![34]; __reduce_map.extend(__rustylr_tset30.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![34]), ruleset : { let rules : & 'static [u8] = &
            [34, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
            76, 77, 78,]; let shifted : & 'static [u8] = & [3, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(26, ::rusty_lr::parser::state::ShiftTarget::new(130, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [29,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![29]; __reduce_map
            .extend(__rustylr_tset9.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![29]), ruleset : { let rules : & 'static [u8] = & [29,]; let shifted
            : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![35]; __reduce_map.extend(__rustylr_tset30.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![35]), ruleset : { let rules : & 'static [u8] = &
            [35, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
            76, 77, 78,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (1,
            ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(136, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 22, 23, 24, 25, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![6]; __reduce_map
            .extend(__rustylr_tset31.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![6, 25]; __reduce_map
            .extend(__rustylr_tset22.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![25]; __reduce_map
            .extend(__rustylr_tset32.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![6, 25]), ruleset : { let rules : & 'static [u8] = &
            [6, 25,]; let shifted : & 'static [u8] = & [1, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(24, ::rusty_lr::parser::state::ShiftTarget::new(135, true)), (34,
            ::rusty_lr::parser::state::ShiftTarget::new(147, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [5, 32,]; let shifted : & 'static [u8] = & [1,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::ExpList1,
            ::rusty_lr::parser::state::ShiftTarget::new(146, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [5, 21, 22, 23, 24, 25, 26, 27, 28, 34, 35,
            45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
            64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let
            shifted : & 'static [u8] = & [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted
            as usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (30,
            ::rusty_lr::parser::state::ShiftTarget::new(137, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [22, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
            71, 72, 73, 74, 75, 76, 77, 78,]; let shifted : & 'static [u8] = & [3, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![22]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![22]), ruleset : { let rules : & 'static [u8] = & [22,]; let shifted
            : & 'static [u8] = & [4,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(139, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [28,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(1,
            ::rusty_lr::parser::state::ShiftTarget::new(30, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(31, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Args,
            ::rusty_lr::parser::state::ShiftTarget::new(140, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(141, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [28, 29, 30, 31, 79,]; let shifted : & 'static
            [u8] = & [3, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![28]; __reduce_map.extend(__rustylr_tset9.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![28]), ruleset : { let rules :
            & 'static [u8] = & [28,]; let shifted : & 'static [u8] = & [4,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![30]; __reduce_map
            .extend(__rustylr_tset9.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![30]), ruleset : { let rules : & 'static [u8] = & [30,]; let shifted
            : & 'static [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(143, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [23,]; let shifted : & 'static [u8] = & [2,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![23]; __reduce_map
            .extend(__rustylr_tset1.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![23]), ruleset : { let rules : & 'static [u8] = & [23,]; let shifted
            : & 'static [u8] = & [3,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![27]; __reduce_map.extend(__rustylr_tset9.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![27]), ruleset : { let rules :
            & 'static [u8] = & [27,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![53]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![53]), ruleset : { let rules : & 'static [u8] = & [53,]; let shifted
            : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(34, ::rusty_lr::parser::state::ShiftTarget::new(127, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![5]; __reduce_map.extend(__rustylr_tset19.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![5]), ruleset : { let rules : &
            'static [u8] = & [5, 34,]; let shifted : & 'static [u8] = & [3, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(148, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 32,]; let
            shifted : & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![24]; __reduce_map
            .extend(__rustylr_tset33.iter().map(| term | (* term, reduce_rules
            .clone()))); let reduce_rules = vec![32]; __reduce_map
            .extend(__rustylr_tset34.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [24, 32,]; let
            shifted : & 'static [u8] = & [1, 3,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(1, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(150, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![96]; __reduce_map.extend(__rustylr_tset35.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![96]), ruleset : { let rules : & 'static [u8] = &
            [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25,
            26, 27, 28, 32, 33, 95, 96,]; let shifted : & 'static [u8] = & [0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![95]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![95]), ruleset : { let rules : & 'static [u8] = &
            [95,]; let shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(53, ::rusty_lr::parser::state::ShiftTarget::new(152, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::ReturnStatement,
            ::rusty_lr::parser::state::ShiftTarget::new(161, true)),
            (ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion29,
            ::rusty_lr::parser::state::ShiftTarget::new(162, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![99]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![99]), ruleset : { let rules : & 'static [u8] = &
            [3, 20, 98, 99,]; let shifted : & 'static [u8] = & [1, 0, 0, 0,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::ExpList1,
            ::rusty_lr::parser::state::ShiftTarget::new(126, true)),
            (ChunkOrExpressionsNonTerminals::ExpList0,
            ::rusty_lr::parser::state::ShiftTarget::new(158, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![37]; __reduce_map.extend(__rustylr_tset37.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![37]), ruleset : { let rules : & 'static [u8] = &
            [20, 21, 22, 23, 24, 25, 26, 27, 28, 34, 35, 36, 37, 45, 46, 47, 48, 49, 50,
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69,
            70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : & 'static [u8] =
            & [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![86]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![86]), ruleset : { let rules : & 'static [u8] = & [86,]; let shifted
            : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![57]; __reduce_map.extend(__rustylr_tset2.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![57]), ruleset : { let rules :
            & 'static [u8] = & [57,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![54]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![54]), ruleset : { let rules : & 'static [u8] = & [54,]; let shifted
            : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![55]; __reduce_map.extend(__rustylr_tset2.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![55]), ruleset : { let rules :
            & 'static [u8] = & [55,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![56]; __reduce_map
            .extend(__rustylr_tset2.iter().map(| term | (* term, reduce_rules.clone())));
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce :
            Some(vec![56]), ruleset : { let rules : & 'static [u8] = & [56,]; let shifted
            : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, &
            shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted
            : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(32, ::rusty_lr::parser::state::ShiftTarget::new(159, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::_semicolonQuestion38,
            ::rusty_lr::parser::state::ShiftTarget::new(160, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![114]; __reduce_map.extend(__rustylr_tset36.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![114]), ruleset : { let rules : & 'static [u8] =
            & [20, 113, 114,]; let shifted : & 'static [u8] = & [2, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![113]; __reduce_map
            .extend(__rustylr_tset36.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![113]), ruleset : { let rules : & 'static [u8] = &
            [113,]; let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![20]; __reduce_map.extend(__rustylr_tset36.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![20]), ruleset : { let rules :
            & 'static [u8] = & [20,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![98]; __reduce_map
            .extend(__rustylr_tset36.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![98]), ruleset : { let rules : & 'static [u8] = &
            [98,]; let shifted : & 'static [u8] = & [1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![3]; __reduce_map.extend(__rustylr_tset36.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![3]), ruleset : { let rules : &
            'static [u8] = & [3,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(164, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [11, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
            71, 72, 73, 74, 75, 76, 77, 78,]; let shifted : & 'static [u8] = & [2, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(165, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26,
            27, 28, 32, 33, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(43,
            ::rusty_lr::parser::state::ShiftTarget::new(166, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [11,]; let shifted : & 'static [u8] = & [4,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![11]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![11]), ruleset : { let rules : & 'static [u8] = &
            [11,]; let shifted : & 'static [u8] = & [5,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(43, ::rusty_lr::parser::state::ShiftTarget::new(168, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [10,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![10]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![10]), ruleset : { let rules : & 'static [u8] = &
            [10,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (34,
            ::rusty_lr::parser::state::ShiftTarget::new(170, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [14, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
            71, 72, 73, 74, 75, 76, 77, 78,]; let shifted : & 'static [u8] = & [4, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(171, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [14, 21, 22, 23, 24, 25, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (34,
            ::rusty_lr::parser::state::ShiftTarget::new(172, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::_Group34,
            ::rusty_lr::parser::state::ShiftTarget::new(174, true)),
            (ChunkOrExpressionsNonTerminals::__Group34Question35,
            ::rusty_lr::parser::state::ShiftTarget::new(175, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![109]; __reduce_map.extend(__rustylr_tset38.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [14, 58,
            59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
            78, 107, 108, 109,]; let shifted : & 'static [u8] = & [6, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(173, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86, 107,]; let shifted :
            & 'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![107]; __reduce_map.extend(__rustylr_tset38.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [58, 59,
            60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
            107,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![108]; __reduce_map.extend(__rustylr_tset38.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [108,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(40,
            ::rusty_lr::parser::state::ShiftTarget::new(176, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [14,]; let shifted : & 'static [u8] = & [7,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(177, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 13, 14, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26,
            27, 28, 32, 33, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(43,
            ::rusty_lr::parser::state::ShiftTarget::new(178, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [14,]; let shifted : & 'static [u8] = & [9,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![14]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![14]), ruleset : { let rules : & 'static [u8] = &
            [14,]; let shifted : & 'static [u8] = & [10,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(34, ::rusty_lr::parser::state::ShiftTarget::new(180, true)), (48,
            ::rusty_lr::parser::state::ShiftTarget::new(181, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [15, 38,]; let shifted : & 'static [u8] = &
            [2, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(21, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [38,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::ExpList1,
            ::rusty_lr::parser::state::ShiftTarget::new(182, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(131, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [15, 21, 22, 23, 24, 25, 26, 27, 28, 34, 35,
            45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
            64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let
            shifted : & 'static [u8] = & [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) |
            { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted
            as usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(34,
            ::rusty_lr::parser::state::ShiftTarget::new(127, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(183, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [15, 34,]; let shifted : & 'static [u8] = &
            [4, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(184, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26,
            27, 28, 32, 33, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(43,
            ::rusty_lr::parser::state::ShiftTarget::new(185, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [15,]; let shifted : & 'static [u8] = & [6,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![15]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![15]), ruleset : { let rules : & 'static [u8] = &
            [15,]; let shifted : & 'static [u8] = & [7,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![16]; __reduce_map.extend(__rustylr_tset19.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![16]), ruleset : { let rules :
            & 'static [u8] = & [16,]; let shifted : & 'static [u8] = & [3,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)), (54,
            ::rusty_lr::parser::state::ShiftTarget::new(188, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [13, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
            68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,]; let shifted : & 'static [u8] =
            & [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(197, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset39.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 13, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26,
            27, 28, 32, 33, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(34,
            ::rusty_lr::parser::state::ShiftTarget::new(127, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![110]; __reduce_map.extend(__rustylr_tset19.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![110]), ruleset : { let rules : & 'static [u8] =
            & [34, 110,]; let shifted : & 'static [u8] = & [1, 2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(108, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::AttName,
            ::rusty_lr::parser::state::ShiftTarget::new(191, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [40, 41,]; let shifted : & 'static [u8] = &
            [0, 2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![41]; __reduce_map
            .extend(__rustylr_tset24.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![41]), ruleset : { let rules : & 'static [u8] = &
            [41,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![111]; __reduce_map.extend(__rustylr_tset19.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : Some(vec![111]), ruleset : { let rules :
            & 'static [u8] = & [111,]; let shifted : & 'static [u8] = & [1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![18]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![18]), ruleset : { let rules : & 'static [u8] = &
            [18,]; let shifted : & 'static [u8] = & [3,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(55, ::rusty_lr::parser::state::ShiftTarget::new(195, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [12,]; let shifted : & 'static
            [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(196, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [12, 21, 22, 23, 24, 25, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![12]; __reduce_map.extend(__rustylr_tset19.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : Some(vec![12]), ruleset : { let rules : & 'static [u8] = &
            [12, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
            76, 77, 78,]; let shifted : & 'static [u8] = & [4, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules.iter().zip(shifted.iter()).map(|
            (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as
            usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term :
            vec![(42, ::rusty_lr::parser::state::ShiftTarget::new(198, true)),],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::ElseIf,
            ::rusty_lr::parser::state::ShiftTarget::new(202, true)),
            (ChunkOrExpressionsNonTerminals::_ElseIfPlus30,
            ::rusty_lr::parser::state::ShiftTarget::new(203, true)),
            (ChunkOrExpressionsNonTerminals::_ElseIfStar31,
            ::rusty_lr::parser::state::ShiftTarget::new(205, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![103]; __reduce_map.extend(__rustylr_tset40.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [13, 19,
            100, 101, 102, 103,]; let shifted : & 'static [u8] = & [4, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(199, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [19, 21, 22, 23, 24, 25, 26, 27, 28, 45, 46,
            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65,
            66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 86,]; let shifted : &
            'static [u8] = & [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)), (54,
            ::rusty_lr::parser::state::ShiftTarget::new(200, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [19, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
            68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,]; let shifted : & 'static [u8] =
            & [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,]; rules
            .iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(201, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset39.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 21, 22, 23, 24, 25, 26,
            27, 28, 32, 33, 94, 95, 96, 97,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![19]; __reduce_map
            .extend(__rustylr_tset41.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [19,]; let
            shifted : & 'static [u8] = & [4,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![100]; __reduce_map.extend(__rustylr_tset41.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [100,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(42,
            ::rusty_lr::parser::state::ShiftTarget::new(198, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::ElseIf,
            ::rusty_lr::parser::state::ShiftTarget::new(204, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![102]; __reduce_map.extend(__rustylr_tset40.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [19, 101,
            102,]; let shifted : & 'static [u8] = & [0, 1, 1,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![101]; __reduce_map.extend(__rustylr_tset41.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [101,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(41,
            ::rusty_lr::parser::state::ShiftTarget::new(206, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::_Group32,
            ::rusty_lr::parser::state::ShiftTarget::new(208, true)),
            (ChunkOrExpressionsNonTerminals::__Group32Question33,
            ::rusty_lr::parser::state::ShiftTarget::new(209, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![106]; __reduce_map.extend(__rustylr_tset42.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [13, 104,
            105, 106,]; let shifted : & 'static [u8] = & [5, 0, 0, 0,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (25, ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (31,
            ::rusty_lr::parser::state::ShiftTarget::new(80, true)), (32,
            ::rusty_lr::parser::state::ShiftTarget::new(83, true)), (39,
            ::rusty_lr::parser::state::ShiftTarget::new(84, true)), (40,
            ::rusty_lr::parser::state::ShiftTarget::new(85, true)), (44,
            ::rusty_lr::parser::state::ShiftTarget::new(86, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(89, true)), (46,
            ::rusty_lr::parser::state::ShiftTarget::new(97, true)), (47,
            ::rusty_lr::parser::state::ShiftTarget::new(99, true)), (49,
            ::rusty_lr::parser::state::ShiftTarget::new(107, true)), (52,
            ::rusty_lr::parser::state::ShiftTarget::new(119, true)), (56,
            ::rusty_lr::parser::state::ShiftTarget::new(120, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Block,
            ::rusty_lr::parser::state::ShiftTarget::new(207, true)),
            (ChunkOrExpressionsNonTerminals::Statement,
            ::rusty_lr::parser::state::ShiftTarget::new(123, true)),
            (ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(124, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(125, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(133, true)),
            (ChunkOrExpressionsNonTerminals::VarList,
            ::rusty_lr::parser::state::ShiftTarget::new(134, true)),
            (ChunkOrExpressionsNonTerminals::_StatementPlus27,
            ::rusty_lr::parser::state::ShiftTarget::new(149, true)),
            (ChunkOrExpressionsNonTerminals::_StatementStar28,
            ::rusty_lr::parser::state::ShiftTarget::new(151, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![97]; __reduce_map.extend(__rustylr_tset8.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [3, 4, 5,
            6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 22, 23, 24, 25, 26, 27,
            28, 32, 33, 94, 95, 96, 97, 104,]; let shifted : & 'static [u8] = & [0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![104]; __reduce_map
            .extend(__rustylr_tset42.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [104,]; let
            shifted : & 'static [u8] = & [2,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : None, shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new(); let
            reduce_rules = vec![105]; __reduce_map.extend(__rustylr_tset42.iter().map(|
            term | (* term, reduce_rules.clone()))); __reduce_map.into_iter().collect()
            }, error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [105,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(43,
            ::rusty_lr::parser::state::ShiftTarget::new(210, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [13,]; let shifted : & 'static [u8] = & [6,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); let reduce_rules = vec![13]; __reduce_map
            .extend(__rustylr_tset19.iter().map(| term | (* term, reduce_rules
            .clone()))); __reduce_map.into_iter().collect() }, error_reduce : None,
            eof_reduce : Some(vec![13]), ruleset : { let rules : & 'static [u8] = &
            [13,]; let shifted : & 'static [u8] = & [7,]; rules.iter().zip(shifted
            .iter()).map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef {
            rule : rule as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (30,
            ::rusty_lr::parser::state::ShiftTarget::new(212, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); __reduce_map.into_iter()
            .collect() }, error_reduce : None, eof_reduce : None, ruleset : { let rules :
            & 'static [u8] = & [58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71,
            72, 73, 74, 75, 76, 77, 78, 81,]; let shifted : & 'static [u8] = & [1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(24,
            ::rusty_lr::parser::state::ShiftTarget::new(213, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [81,]; let shifted : & 'static [u8] = & [3,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(0, ::rusty_lr::parser::state::ShiftTarget::new(1,
            true)), (1, ::rusty_lr::parser::state::ShiftTarget::new(2, true)), (2,
            ::rusty_lr::parser::state::ShiftTarget::new(3, true)), (3,
            ::rusty_lr::parser::state::ShiftTarget::new(4, true)), (4,
            ::rusty_lr::parser::state::ShiftTarget::new(5, true)), (5,
            ::rusty_lr::parser::state::ShiftTarget::new(6, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(7, true)), (11,
            ::rusty_lr::parser::state::ShiftTarget::new(8, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(9, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(10, true)), (27,
            ::rusty_lr::parser::state::ShiftTarget::new(11, true)), (37,
            ::rusty_lr::parser::state::ShiftTarget::new(14, true)), (45,
            ::rusty_lr::parser::state::ShiftTarget::new(15, true)), (50,
            ::rusty_lr::parser::state::ShiftTarget::new(28, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::Var,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::PrefixExp,
            ::rusty_lr::parser::state::ShiftTarget::new(29, true)),
            (ChunkOrExpressionsNonTerminals::FunctionCall,
            ::rusty_lr::parser::state::ShiftTarget::new(32, true)),
            (ChunkOrExpressionsNonTerminals::Exp,
            ::rusty_lr::parser::state::ShiftTarget::new(214, true)),
            (ChunkOrExpressionsNonTerminals::TableConstructor,
            ::rusty_lr::parser::state::ShiftTarget::new(40, true)),
            (ChunkOrExpressionsNonTerminals::FunctionDef,
            ::rusty_lr::parser::state::ShiftTarget::new(41, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [21, 22, 23, 24, 25, 26, 27, 28, 45, 46, 47,
            48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66,
            67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 81, 86,]; let shifted : &
            'static [u8] = & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,];
            rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![81]; __reduce_map.extend(__rustylr_tset23.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [58, 59,
            60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
            81,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 5,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(5,
            ::rusty_lr::parser::state::ShiftTarget::new(34, true)), (6,
            ::rusty_lr::parser::state::ShiftTarget::new(48, true)), (7,
            ::rusty_lr::parser::state::ShiftTarget::new(36, true)), (8,
            ::rusty_lr::parser::state::ShiftTarget::new(42, true)), (9,
            ::rusty_lr::parser::state::ShiftTarget::new(44, true)), (10,
            ::rusty_lr::parser::state::ShiftTarget::new(38, true)), (12,
            ::rusty_lr::parser::state::ShiftTarget::new(50, true)), (13,
            ::rusty_lr::parser::state::ShiftTarget::new(58, true)), (14,
            ::rusty_lr::parser::state::ShiftTarget::new(60, true)), (15,
            ::rusty_lr::parser::state::ShiftTarget::new(52, true)), (16,
            ::rusty_lr::parser::state::ShiftTarget::new(56, true)), (17,
            ::rusty_lr::parser::state::ShiftTarget::new(46, true)), (18,
            ::rusty_lr::parser::state::ShiftTarget::new(62, true)), (19,
            ::rusty_lr::parser::state::ShiftTarget::new(64, true)), (20,
            ::rusty_lr::parser::state::ShiftTarget::new(66, true)), (21,
            ::rusty_lr::parser::state::ShiftTarget::new(68, true)), (22,
            ::rusty_lr::parser::state::ShiftTarget::new(70, true)), (23,
            ::rusty_lr::parser::state::ShiftTarget::new(72, true)), (36,
            ::rusty_lr::parser::state::ShiftTarget::new(54, true)), (38,
            ::rusty_lr::parser::state::ShiftTarget::new(75, true)), (51,
            ::rusty_lr::parser::state::ShiftTarget::new(77, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let mut
            __reduce_map = std::collections::BTreeMap::new(); let reduce_rules =
            vec![82]; __reduce_map.extend(__rustylr_tset23.iter().map(| term | (* term,
            reduce_rules.clone()))); __reduce_map.into_iter().collect() }, error_reduce :
            None, eof_reduce : None, ruleset : { let rules : & 'static [u8] = & [58, 59,
            60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
            82,]; let shifted : & 'static [u8] = & [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 3,]; rules.iter().zip(shifted.iter()).map(| (&
            rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize,
            shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![(0,
            ::rusty_lr::parser::state::ShiftTarget::new(90, true)), (25,
            ::rusty_lr::parser::state::ShiftTarget::new(16, true)),], error_shift : None,
            eof_shift : None, shift_goto_map_nonterm :
            vec![(ChunkOrExpressionsNonTerminals::FuncBody,
            ::rusty_lr::parser::state::ShiftTarget::new(153, true)),
            (ChunkOrExpressionsNonTerminals::FuncName1,
            ::rusty_lr::parser::state::ShiftTarget::new(91, true)),
            (ChunkOrExpressionsNonTerminals::FuncName,
            ::rusty_lr::parser::state::ShiftTarget::new(96, true)),], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : None, ruleset : {
            let rules : & 'static [u8] = & [16, 86, 87, 88, 89, 90, 91,]; let shifted : &
            'static [u8] = & [1, 1, 0, 0, 0, 0, 0,]; rules.iter().zip(shifted.iter())
            .map(| (& rule, & shifted) | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule
            as usize, shifted : shifted as usize, } }).collect() } },
            ::rusty_lr::parser::state::IntermediateState { shift_goto_map_term : vec![],
            error_shift : None, eof_shift : Some(218), shift_goto_map_nonterm : vec![],
            reduce_map : { let mut __reduce_map = std::collections::BTreeMap::new();
            __reduce_map.into_iter().collect() }, error_reduce : None, eof_reduce : None,
            ruleset : { let rules : & 'static [u8] = & [124,]; let shifted : & 'static
            [u8] = & [1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : None, ruleset : { let rules : & 'static
            [u8] = & [124,]; let shifted : & 'static [u8] = & [2,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![], error_shift : None, eof_shift : None,
            shift_goto_map_nonterm : vec![], reduce_map : { let mut __reduce_map =
            std::collections::BTreeMap::new(); __reduce_map.into_iter().collect() },
            error_reduce : None, eof_reduce : Some(vec![0]), ruleset : { let rules : &
            'static [u8] = & [0,]; let shifted : & 'static [u8] = & [1,]; rules.iter()
            .zip(shifted.iter()).map(| (& rule, & shifted) | {
            ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted : shifted as
            usize, } }).collect() } }, ::rusty_lr::parser::state::IntermediateState {
            shift_goto_map_term : vec![(34,
            ::rusty_lr::parser::state::ShiftTarget::new(127, true)),], error_shift :
            None, eof_shift : None, shift_goto_map_nonterm : vec![], reduce_map : { let
            mut __reduce_map = std::collections::BTreeMap::new(); __reduce_map
            .into_iter().collect() }, error_reduce : None, eof_reduce : Some(vec![1]),
            ruleset : { let rules : & 'static [u8] = & [1, 34,]; let shifted : & 'static
            [u8] = & [1, 1,]; rules.iter().zip(shifted.iter()).map(| (& rule, & shifted)
            | { ::rusty_lr::rule::ShiftedRuleRef { rule : rule as usize, shifted :
            shifted as usize, } }).collect() } },
        ];
        let states: Vec<ChunkOrExpressionsState> = states
            .into_iter()
            .map(|state| state.into())
            .collect();
        Self {
            rules,
            states,
            classes: vec![
                vec!["ident",], vec!["string_literal",], vec!["numeric_literal",],
                vec!["nil",], vec!["bool_",], vec!["plus",], vec!["minus",],
                vec!["asterisk",], vec!["slash",], vec!["percent",], vec!["caret",],
                vec!["hash",], vec!["ampersand",], vec!["tilde",], vec!["pipe",],
                vec!["lessless",], vec!["greatergreater",], vec!["slashslash",],
                vec!["equalequal",], vec!["tildeequal",], vec!["lessequal",],
                vec!["greaterequal",], vec!["less",], vec!["greater",], vec!["equal",],
                vec!["lparen",], vec!["rparen",], vec!["lbrace",], vec!["rbrace",],
                vec!["lbracket",], vec!["rbracket",], vec!["coloncolon",],
                vec!["semicolon",], vec!["colon",], vec!["comma",], vec!["dot",],
                vec!["dotdot",], vec!["dotdotdot",], vec!["and_",], vec!["break_",],
                vec!["do_",], vec!["else_",], vec!["elseif_",], vec!["end_",],
                vec!["for_",], vec!["function_",], vec!["goto_",], vec!["if_",],
                vec!["in_",], vec!["local_",], vec!["not_",], vec!["or_",],
                vec!["repeat_",], vec!["return_",], vec!["then_",], vec!["until_",],
                vec!["while_",],
            ],
        }
    }
}

// ==============================Generated Codes End===============================
        