// This file was generated by rustylr 1.8.0
// This generated code is targeting rusty_lr version 3.16.0.
// There might be a build error if the version is not matched.
//
// Input file: parser.rs
// Output file: parser_expanded.rs
// ================================User Codes Begin================================
use crate::expression;
use crate::statement;
use crate::ChunkOrExpressions;
use crate::Expression;
use crate::ParseError;
use crate::Span;
use crate::SpannedString;
use crate::Statement;
use lua_tokenizer::IntOrFloat;
use lua_tokenizer::Token;
use lua_tokenizer::TokenType;
macro_rules! new_binary_node {
    ($ variant : ident , $ op : ident , $ lhs : ident , $ rhs : ident) => {{
        let span = $lhs.span().merge_ordered(&$rhs.span());
        let span_op = $op.span();
        let binary_data = expression::ExprBinaryData::new($lhs, $rhs, span, span_op);
        Expression::Binary(expression::ExprBinary::$variant(binary_data))
    }};
}
macro_rules! new_unary_node {
    ($ variant : ident , $ op : ident , $ lhs : ident) => {{
        let span = $op.span().merge_ordered(&$lhs.span());
        let span_op = $op.span();
        let unary_data = expression::ExprUnaryData::new($lhs, span, span_op);
        Expression::Unary(expression::ExprUnary::$variant(unary_data))
    }};
}
// =================================User Codes End=================================
/*
====================================Grammar=====================================

# of terminal classes: 59
# of states: 227

ChunkOrExpressions -> Chunk
ChunkOrExpressions -> ExpList1
Chunk -> Block
Block -> Statement* ReturnStatement?
Statement -> semicolon
Statement -> VarList equal ExpList1
Statement -> FunctionCall
Statement -> coloncolon ident coloncolon
Statement -> break_
Statement -> goto_ ident
Statement -> do_ Block end_
Statement -> while_ Exp do_ Block end_
Statement -> repeat_ Block until_ Exp
Statement -> if_ Exp then_ Block ElseIf* (else_, Block)? end_
Statement -> for_ ident equal Exp comma Exp (comma, Exp)? do_ Block end_
Statement -> for_ NameList in_ ExpList1 do_ Block end_
Statement -> function_ FuncName FuncBody
Statement -> local_ function_ ident FuncBody
Statement -> local_ AttNameList (equal, ExpList1)?
ElseIf -> elseif_ Exp then_ Block
ReturnStatement -> return_ ExpList0 semicolon?
Var -> ident
Var -> PrefixExp lbracket Exp rbracket
Var -> PrefixExp dot ident
PrefixExp -> Var
PrefixExp -> FunctionCall
PrefixExp -> lparen Exp rparen
FunctionCall -> PrefixExp Args
FunctionCall -> PrefixExp colon ident Args
Args -> lparen ExpList0 rparen
Args -> TableConstructor
Args -> string_literal
VarList -> VarList comma Var
VarList -> Var
ExpList1 -> ExpList1 comma Exp
ExpList1 -> Exp
ExpList0 -> ExpList1
ExpList0 ->
NameList -> NameList comma ident
NameList -> ident
AttName -> ident Attrib
AttNameList -> AttNameList comma AttName
AttNameList -> AttName
Attrib -> less ident greater
Attrib ->
Exp0 -> numeric_literal
Exp0 -> nil
Exp0 -> string_literal
Exp0 -> bool_
Exp0 -> dotdotdot
Exp0 -> FunctionDef
Exp0 -> PrefixExp
Exp0 -> TableConstructor
Exp -> Exp0
Exp -> not_ Exp
Exp -> hash Exp
Exp -> minus Exp
Exp -> plus Exp
Exp -> tilde Exp
Exp -> Exp asterisk Exp
Exp -> Exp slash Exp
Exp -> Exp slashslash Exp
Exp -> Exp percent Exp
Exp -> Exp plus Exp
Exp -> Exp minus Exp
Exp -> Exp dotdot Exp
Exp -> Exp lessless Exp
Exp -> Exp greatergreater Exp
Exp -> Exp ampersand Exp
Exp -> Exp tilde Exp
Exp -> Exp pipe Exp
Exp -> Exp less Exp
Exp -> Exp lessequal Exp
Exp -> Exp greater Exp
Exp -> Exp greaterequal Exp
Exp -> Exp tildeequal Exp
Exp -> Exp equalequal Exp
Exp -> Exp and_ Exp
Exp -> Exp or_ Exp
Exp -> Exp caret Exp
TableConstructor -> lbrace FieldList rbrace
FieldList1 -> FieldList1 FieldSep Field
FieldList1 -> Field
FieldList -> FieldList1 FieldSep?
FieldList ->
Field -> lbracket Exp rbracket equal Exp
Field -> ident equal Exp
Field -> Exp
FieldSep -> comma
FieldSep -> semicolon
FunctionDef -> function_ FuncBody
FuncBody -> lparen ParList? rparen Block end_
FuncName1 -> FuncName1 dot ident
FuncName1 -> ident
FuncName -> FuncName1 colon ident
FuncName -> FuncName1
ParList -> NameList (comma, dotdotdot)?
ParList -> dotdotdot
Statement+ -> Statement
Statement+ -> Statement+ Statement
Statement* -> Statement+
Statement* ->
ReturnStatement? -> ReturnStatement
ReturnStatement? ->
ElseIf+ -> ElseIf
ElseIf+ -> ElseIf+ ElseIf
ElseIf* -> ElseIf+
ElseIf* ->
(else_, Block) -> else_ Block
(else_, Block)? -> (else_, Block)
(else_, Block)? ->
(comma, Exp) -> comma Exp
(comma, Exp)? -> (comma, Exp)
(comma, Exp)? ->
(equal, ExpList1) -> equal ExpList1
(equal, ExpList1)? -> (equal, ExpList1)
(equal, ExpList1)? ->
semicolon? -> semicolon
semicolon? ->
FieldSep? -> FieldSep
FieldSep? ->
ParList? -> ParList
ParList? ->
(comma, dotdotdot) -> comma dotdotdot
(comma, dotdotdot)? -> (comma, dotdotdot)
(comma, dotdotdot)? ->
Augmented -> ChunkOrExpressions eof

*/
// =============================Generated Codes Begin==============================
#[doc = r" type alias for `Context`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsContext = ::rusty_lr::glr::Context<ChunkOrExpressionsNodeEnum>;
#[doc = r" type alias for CFG production rule"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsRule =
    ::rusty_lr::ProductionRule<&'static str, ChunkOrExpressionsNonTerminals>;
#[doc = r" type alias for DFA state"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsState = ::rusty_lr::glr::SparseState<ChunkOrExpressionsNonTerminals>;
#[doc = r" type alias for `InvalidTerminalError`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsInvalidTerminalError =
    ::rusty_lr::glr::InvalidTerminalError<Token, ChunkOrExpressionsNonTerminals, ParseError>;
#[doc = r" type alias for `MultiplePathError`"]
#[allow(non_camel_case_types, dead_code)]
pub type ChunkOrExpressionsMultiplePathError =
    ::rusty_lr::glr::MultiplePathError<Token, ChunkOrExpressionsNonTerminals>;
#[doc = r" An enum that represents non-terminal symbols"]
#[allow(non_camel_case_types, dead_code)]
#[derive(
    Clone,
    Copy,
    std :: hash :: Hash,
    std :: cmp :: PartialEq,
    std :: cmp :: Eq,
    std :: cmp :: PartialOrd,
    std :: cmp :: Ord,
)]
pub enum ChunkOrExpressionsNonTerminals {
    ChunkOrExpressions,
    Chunk,
    Block,
    Statement,
    ElseIf,
    ReturnStatement,
    Var,
    PrefixExp,
    FunctionCall,
    Args,
    VarList,
    ExpList1,
    ExpList0,
    NameList,
    AttName,
    AttNameList,
    Attrib,
    Exp0,
    Exp,
    TableConstructor,
    FieldList1,
    FieldList,
    Field,
    FieldSep,
    FunctionDef,
    FuncBody,
    FuncName1,
    FuncName,
    ParList,
    error,
    _StatementPlus30,
    _StatementStar31,
    _ReturnStatementQuestion32,
    _ElseIfPlus33,
    _ElseIfStar34,
    _Group35,
    __Group35Question36,
    _Group37,
    __Group37Question38,
    _Group39,
    __Group39Question40,
    _semicolonQuestion41,
    _FieldSepQuestion42,
    _ParListQuestion43,
    _Group44,
    __Group44Question45,
    Augmented,
}
impl ChunkOrExpressionsNonTerminals {
    #[doc = r" convert to string"]
    pub fn as_str(&self) -> &'static str {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => "ChunkOrExpressions",
            ChunkOrExpressionsNonTerminals::Chunk => "Chunk",
            ChunkOrExpressionsNonTerminals::Block => "Block",
            ChunkOrExpressionsNonTerminals::Statement => "Statement",
            ChunkOrExpressionsNonTerminals::ElseIf => "ElseIf",
            ChunkOrExpressionsNonTerminals::ReturnStatement => "ReturnStatement",
            ChunkOrExpressionsNonTerminals::Var => "Var",
            ChunkOrExpressionsNonTerminals::PrefixExp => "PrefixExp",
            ChunkOrExpressionsNonTerminals::FunctionCall => "FunctionCall",
            ChunkOrExpressionsNonTerminals::Args => "Args",
            ChunkOrExpressionsNonTerminals::VarList => "VarList",
            ChunkOrExpressionsNonTerminals::ExpList1 => "ExpList1",
            ChunkOrExpressionsNonTerminals::ExpList0 => "ExpList0",
            ChunkOrExpressionsNonTerminals::NameList => "NameList",
            ChunkOrExpressionsNonTerminals::AttName => "AttName",
            ChunkOrExpressionsNonTerminals::AttNameList => "AttNameList",
            ChunkOrExpressionsNonTerminals::Attrib => "Attrib",
            ChunkOrExpressionsNonTerminals::Exp0 => "Exp0",
            ChunkOrExpressionsNonTerminals::Exp => "Exp",
            ChunkOrExpressionsNonTerminals::TableConstructor => "TableConstructor",
            ChunkOrExpressionsNonTerminals::FieldList1 => "FieldList1",
            ChunkOrExpressionsNonTerminals::FieldList => "FieldList",
            ChunkOrExpressionsNonTerminals::Field => "Field",
            ChunkOrExpressionsNonTerminals::FieldSep => "FieldSep",
            ChunkOrExpressionsNonTerminals::FunctionDef => "FunctionDef",
            ChunkOrExpressionsNonTerminals::FuncBody => "FuncBody",
            ChunkOrExpressionsNonTerminals::FuncName1 => "FuncName1",
            ChunkOrExpressionsNonTerminals::FuncName => "FuncName",
            ChunkOrExpressionsNonTerminals::ParList => "ParList",
            ChunkOrExpressionsNonTerminals::error => "'error'",
            ChunkOrExpressionsNonTerminals::_StatementPlus30 => "Statement+",
            ChunkOrExpressionsNonTerminals::_StatementStar31 => "Statement*",
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion32 => "ReturnStatement?",
            ChunkOrExpressionsNonTerminals::_ElseIfPlus33 => "ElseIf+",
            ChunkOrExpressionsNonTerminals::_ElseIfStar34 => "ElseIf*",
            ChunkOrExpressionsNonTerminals::_Group35 => "(else_, Block)",
            ChunkOrExpressionsNonTerminals::__Group35Question36 => "(else_, Block)?",
            ChunkOrExpressionsNonTerminals::_Group37 => "(comma, Exp)",
            ChunkOrExpressionsNonTerminals::__Group37Question38 => "(comma, Exp)?",
            ChunkOrExpressionsNonTerminals::_Group39 => "(equal, ExpList1)",
            ChunkOrExpressionsNonTerminals::__Group39Question40 => "(equal, ExpList1)?",
            ChunkOrExpressionsNonTerminals::_semicolonQuestion41 => "semicolon?",
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion42 => "FieldSep?",
            ChunkOrExpressionsNonTerminals::_ParListQuestion43 => "ParList?",
            ChunkOrExpressionsNonTerminals::_Group44 => "(comma, dotdotdot)",
            ChunkOrExpressionsNonTerminals::__Group44Question45 => "(comma, dotdotdot)?",
            ChunkOrExpressionsNonTerminals::Augmented => "Augmented",
        }
    }
}
impl std::fmt::Display for ChunkOrExpressionsNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
impl std::fmt::Debug for ChunkOrExpressionsNonTerminals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
impl ::rusty_lr::NonTerminal<Token> for ChunkOrExpressionsNonTerminals {
    fn is_auto_generated(&self) -> bool {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => false,
            ChunkOrExpressionsNonTerminals::Chunk => false,
            ChunkOrExpressionsNonTerminals::Block => false,
            ChunkOrExpressionsNonTerminals::Statement => false,
            ChunkOrExpressionsNonTerminals::ElseIf => false,
            ChunkOrExpressionsNonTerminals::ReturnStatement => false,
            ChunkOrExpressionsNonTerminals::Var => false,
            ChunkOrExpressionsNonTerminals::PrefixExp => false,
            ChunkOrExpressionsNonTerminals::FunctionCall => false,
            ChunkOrExpressionsNonTerminals::Args => false,
            ChunkOrExpressionsNonTerminals::VarList => false,
            ChunkOrExpressionsNonTerminals::ExpList1 => false,
            ChunkOrExpressionsNonTerminals::ExpList0 => false,
            ChunkOrExpressionsNonTerminals::NameList => false,
            ChunkOrExpressionsNonTerminals::AttName => false,
            ChunkOrExpressionsNonTerminals::AttNameList => false,
            ChunkOrExpressionsNonTerminals::Attrib => false,
            ChunkOrExpressionsNonTerminals::Exp0 => false,
            ChunkOrExpressionsNonTerminals::Exp => false,
            ChunkOrExpressionsNonTerminals::TableConstructor => false,
            ChunkOrExpressionsNonTerminals::FieldList1 => false,
            ChunkOrExpressionsNonTerminals::FieldList => false,
            ChunkOrExpressionsNonTerminals::Field => false,
            ChunkOrExpressionsNonTerminals::FieldSep => false,
            ChunkOrExpressionsNonTerminals::FunctionDef => false,
            ChunkOrExpressionsNonTerminals::FuncBody => false,
            ChunkOrExpressionsNonTerminals::FuncName1 => false,
            ChunkOrExpressionsNonTerminals::FuncName => false,
            ChunkOrExpressionsNonTerminals::ParList => false,
            ChunkOrExpressionsNonTerminals::error => false,
            ChunkOrExpressionsNonTerminals::_StatementPlus30 => true,
            ChunkOrExpressionsNonTerminals::_StatementStar31 => true,
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion32 => true,
            ChunkOrExpressionsNonTerminals::_ElseIfPlus33 => true,
            ChunkOrExpressionsNonTerminals::_ElseIfStar34 => true,
            ChunkOrExpressionsNonTerminals::_Group35 => true,
            ChunkOrExpressionsNonTerminals::__Group35Question36 => true,
            ChunkOrExpressionsNonTerminals::_Group37 => true,
            ChunkOrExpressionsNonTerminals::__Group37Question38 => true,
            ChunkOrExpressionsNonTerminals::_Group39 => true,
            ChunkOrExpressionsNonTerminals::__Group39Question40 => true,
            ChunkOrExpressionsNonTerminals::_semicolonQuestion41 => true,
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion42 => true,
            ChunkOrExpressionsNonTerminals::_ParListQuestion43 => true,
            ChunkOrExpressionsNonTerminals::_Group44 => true,
            ChunkOrExpressionsNonTerminals::__Group44Question45 => true,
            ChunkOrExpressionsNonTerminals::Augmented => true,
        }
    }
    fn is_augmented(&self) -> bool {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => false,
            ChunkOrExpressionsNonTerminals::Chunk => false,
            ChunkOrExpressionsNonTerminals::Block => false,
            ChunkOrExpressionsNonTerminals::Statement => false,
            ChunkOrExpressionsNonTerminals::ElseIf => false,
            ChunkOrExpressionsNonTerminals::ReturnStatement => false,
            ChunkOrExpressionsNonTerminals::Var => false,
            ChunkOrExpressionsNonTerminals::PrefixExp => false,
            ChunkOrExpressionsNonTerminals::FunctionCall => false,
            ChunkOrExpressionsNonTerminals::Args => false,
            ChunkOrExpressionsNonTerminals::VarList => false,
            ChunkOrExpressionsNonTerminals::ExpList1 => false,
            ChunkOrExpressionsNonTerminals::ExpList0 => false,
            ChunkOrExpressionsNonTerminals::NameList => false,
            ChunkOrExpressionsNonTerminals::AttName => false,
            ChunkOrExpressionsNonTerminals::AttNameList => false,
            ChunkOrExpressionsNonTerminals::Attrib => false,
            ChunkOrExpressionsNonTerminals::Exp0 => false,
            ChunkOrExpressionsNonTerminals::Exp => false,
            ChunkOrExpressionsNonTerminals::TableConstructor => false,
            ChunkOrExpressionsNonTerminals::FieldList1 => false,
            ChunkOrExpressionsNonTerminals::FieldList => false,
            ChunkOrExpressionsNonTerminals::Field => false,
            ChunkOrExpressionsNonTerminals::FieldSep => false,
            ChunkOrExpressionsNonTerminals::FunctionDef => false,
            ChunkOrExpressionsNonTerminals::FuncBody => false,
            ChunkOrExpressionsNonTerminals::FuncName1 => false,
            ChunkOrExpressionsNonTerminals::FuncName => false,
            ChunkOrExpressionsNonTerminals::ParList => false,
            ChunkOrExpressionsNonTerminals::error => false,
            ChunkOrExpressionsNonTerminals::_StatementPlus30 => false,
            ChunkOrExpressionsNonTerminals::_StatementStar31 => false,
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion32 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfPlus33 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfStar34 => false,
            ChunkOrExpressionsNonTerminals::_Group35 => false,
            ChunkOrExpressionsNonTerminals::__Group35Question36 => false,
            ChunkOrExpressionsNonTerminals::_Group37 => false,
            ChunkOrExpressionsNonTerminals::__Group37Question38 => false,
            ChunkOrExpressionsNonTerminals::_Group39 => false,
            ChunkOrExpressionsNonTerminals::__Group39Question40 => false,
            ChunkOrExpressionsNonTerminals::_semicolonQuestion41 => false,
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion42 => false,
            ChunkOrExpressionsNonTerminals::_ParListQuestion43 => false,
            ChunkOrExpressionsNonTerminals::_Group44 => false,
            ChunkOrExpressionsNonTerminals::__Group44Question45 => false,
            ChunkOrExpressionsNonTerminals::Augmented => true,
        }
    }
    fn is_trace(&self) -> bool {
        match self {
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions => false,
            ChunkOrExpressionsNonTerminals::Chunk => false,
            ChunkOrExpressionsNonTerminals::Block => false,
            ChunkOrExpressionsNonTerminals::Statement => false,
            ChunkOrExpressionsNonTerminals::ElseIf => false,
            ChunkOrExpressionsNonTerminals::ReturnStatement => false,
            ChunkOrExpressionsNonTerminals::Var => false,
            ChunkOrExpressionsNonTerminals::PrefixExp => false,
            ChunkOrExpressionsNonTerminals::FunctionCall => false,
            ChunkOrExpressionsNonTerminals::Args => false,
            ChunkOrExpressionsNonTerminals::VarList => false,
            ChunkOrExpressionsNonTerminals::ExpList1 => false,
            ChunkOrExpressionsNonTerminals::ExpList0 => false,
            ChunkOrExpressionsNonTerminals::NameList => false,
            ChunkOrExpressionsNonTerminals::AttName => false,
            ChunkOrExpressionsNonTerminals::AttNameList => false,
            ChunkOrExpressionsNonTerminals::Attrib => false,
            ChunkOrExpressionsNonTerminals::Exp0 => false,
            ChunkOrExpressionsNonTerminals::Exp => false,
            ChunkOrExpressionsNonTerminals::TableConstructor => false,
            ChunkOrExpressionsNonTerminals::FieldList1 => false,
            ChunkOrExpressionsNonTerminals::FieldList => false,
            ChunkOrExpressionsNonTerminals::Field => false,
            ChunkOrExpressionsNonTerminals::FieldSep => false,
            ChunkOrExpressionsNonTerminals::FunctionDef => false,
            ChunkOrExpressionsNonTerminals::FuncBody => false,
            ChunkOrExpressionsNonTerminals::FuncName1 => false,
            ChunkOrExpressionsNonTerminals::FuncName => false,
            ChunkOrExpressionsNonTerminals::ParList => false,
            ChunkOrExpressionsNonTerminals::error => false,
            ChunkOrExpressionsNonTerminals::_StatementPlus30 => false,
            ChunkOrExpressionsNonTerminals::_StatementStar31 => false,
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion32 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfPlus33 => false,
            ChunkOrExpressionsNonTerminals::_ElseIfStar34 => false,
            ChunkOrExpressionsNonTerminals::_Group35 => false,
            ChunkOrExpressionsNonTerminals::__Group35Question36 => false,
            ChunkOrExpressionsNonTerminals::_Group37 => false,
            ChunkOrExpressionsNonTerminals::__Group37Question38 => false,
            ChunkOrExpressionsNonTerminals::_Group39 => false,
            ChunkOrExpressionsNonTerminals::__Group39Question40 => false,
            ChunkOrExpressionsNonTerminals::_semicolonQuestion41 => false,
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion42 => false,
            ChunkOrExpressionsNonTerminals::_ParListQuestion43 => false,
            ChunkOrExpressionsNonTerminals::_Group44 => false,
            ChunkOrExpressionsNonTerminals::__Group44Question45 => false,
            ChunkOrExpressionsNonTerminals::Augmented => false,
        }
    }
}
#[doc = r" enum for each non-terminal and terminal symbol, that actually hold data"]
#[allow(unused_braces, unused_parens, non_snake_case, non_camel_case_types)]
#[derive(Clone)]
pub enum ChunkOrExpressionsNodeEnum {
    EmptyRuleType,
    Terminals(Token),
    Variant2(ChunkOrExpressions),
    Variant3(statement::Block),
    Variant4(Statement),
    Variant5(statement::StmtElseIf),
    Variant6(statement::ReturnStatement),
    Variant7(Expression),
    Variant8(expression::ExprFunctionCall),
    Variant9(expression::FunctionCallArguments),
    Variant10(Vec<Expression>),
    Variant11(Vec<SpannedString>),
    Variant12(statement::AttName),
    Variant13(Vec<statement::AttName>),
    Variant14(Option<statement::Attrib>),
    Variant15(expression::ExprTable),
    Variant16(Vec<expression::TableField>),
    Variant17(expression::TableField),
    Variant18(expression::ExprFunction),
    Variant19(statement::FunctionName),
    Variant20(expression::ParameterList),
    Variant21(Vec<Statement>),
    Variant22(Option<statement::ReturnStatement>),
    Variant23(Vec<statement::StmtElseIf>),
    Variant24(Option<statement::Block>),
    Variant25(Option<Expression>),
    Variant26(Option<Vec<Expression>>),
    Variant27(Option<Token>),
    Variant28(Option<expression::ParameterList>),
}
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut,
    dead_code
)]
impl ChunkOrExpressionsNodeEnum {
    fn reduce_ChunkOrExpressions_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant3(mut Chunk) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant2({
            ChunkOrExpressions::Chunk(Chunk)
        }))
    }
    fn reduce_ChunkOrExpressions_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant2({
            ChunkOrExpressions::Expressions(ExpList1)
        }))
    }
    fn reduce_Chunk_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant3(Block))
    }
    fn reduce_Block_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant21(mut Statement) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant22(mut ReturnStatement) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant3({
            let span0 = if let Some(first) = Statement.first() {
                first.span()
            } else {
                Span::new_none()
            };
            if let Some(ret) = ReturnStatement {
                let span1 = ret.span();
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, Some(ret), span)
            } else {
                let span1 = if let Some(last) = Statement.last() {
                    last.span()
                } else {
                    Span::new_none()
                };
                let span = span0.merge_ordered(&span1);
                statement::Block::new(Statement, None, span)
            }
        }))
    }
    fn reduce_Statement_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut semicolon) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            Statement::None(statement::StmtNone::new(semicolon.span()))
        }))
    }
    fn reduce_Statement_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant10(mut VarList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut equal) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = VarList
                .first()
                .unwrap()
                .span()
                .merge_ordered(&ExpList1.last().unwrap().span());
            let span_eq = equal.span();
            Statement::Assignment(statement::StmtAssignment::new(
                VarList, ExpList1, span, span_eq,
            ))
        }))
    }
    fn reduce_Statement_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant8(mut FunctionCall) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            Statement::FunctionCall(FunctionCall)
        }))
    }
    fn reduce_Statement_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut c1) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut c2) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = c1.span().merge_ordered(&c2.span());
            Statement::Label(statement::StmtLabel::new(ident.into(), span))
        }))
    }
    fn reduce_Statement_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut break_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            Statement::Break(statement::StmtBreak::new(break_.span()))
        }))
    }
    fn reduce_Statement_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut goto_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = goto_.span().merge_ordered(&ident.span());
            Statement::Goto(statement::StmtGoto::new(ident.into(), span))
        }))
    }
    fn reduce_Statement_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut do_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = do_.span().merge_ordered(&end_.span());
            Statement::Do(statement::StmtDo::new(Block, span))
        }))
    }
    fn reduce_Statement_7(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut while_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = while_.span().merge_ordered(&end_.span());
            Statement::While(statement::StmtWhile::new(Exp, Block, span))
        }))
    }
    fn reduce_Statement_8(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut repeat_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = repeat_.span().merge_ordered(&Exp.span());
            Statement::Repeat(statement::StmtRepeat::new(Block, Exp, span))
        }))
    }
    fn reduce_Statement_9(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut if_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant23(mut elseifs) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant24(mut else_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = if_.span().merge_ordered(&end_.span());
            Statement::If(statement::StmtIf::new(Exp, Block, elseifs, else_, span))
        }))
    }
    fn reduce_Statement_10(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut for_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut start) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut end) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant25(mut step) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = for_.span().merge_ordered(&end_.span());
            Statement::For(statement::StmtFor::new(
                ident.token_type.into_ident().unwrap(),
                start,
                end,
                step.unwrap_or_else(|| {
                    Expression::Numeric(expression::ExprNumeric::new(1.into(), Span::new_none()))
                }),
                Block,
                span,
            ))
        }))
    }
    fn reduce_Statement_11(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut for_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant11(mut NameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = for_.span().merge_ordered(&end_.span());
            Statement::ForGeneric(statement::StmtForGeneric::new(
                NameList, ExpList1, Block, span,
            ))
        }))
    }
    fn reduce_Statement_12(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut function_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant19(mut FuncName) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant18(mut FuncBody) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = function_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinition(statement::StmtFunctionDefinition::new(
                FuncName, FuncBody, span,
            ))
        }))
    }
    fn reduce_Statement_13(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut local_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant18(mut FuncBody) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span = local_.span().merge_ordered(&FuncBody.span());
            Statement::FunctionDefinitionLocal(statement::StmtFunctionDefinitionLocal::new(
                ident.into(),
                FuncBody,
                span,
            ))
        }))
    }
    fn reduce_Statement_14(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut local_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant13(mut AttNameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant26(mut rhs_list) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant4({
            let span0 = local_.span();
            if let Some(rhs) = rhs_list {
                let span = span0.merge_ordered(&rhs.last().unwrap().span());
                Statement::LocalDeclaration(statement::StmtLocalDeclaration::new(
                    AttNameList,
                    Some(rhs),
                    span,
                ))
            } else {
                let span = AttNameList.last().unwrap().span();
                Statement::LocalDeclaration(statement::StmtLocalDeclaration::new(
                    AttNameList,
                    None,
                    span,
                ))
            }
        }))
    }
    fn reduce_ElseIf_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut elseif_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut then_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant5({
            let span = if Block.span().is_none() {
                elseif_.span().merge_ordered(&then_.span())
            } else {
                elseif_.span().merge_ordered(&Block.span())
            };
            statement::StmtElseIf::new(Exp, Block, span)
        }))
    }
    fn reduce_ReturnStatement_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut return_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant10(mut ExpList0) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant27(mut semicolon) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant6({
            let span0 = return_.span();
            let span = if let Some(last) = semicolon {
                span0.merge_ordered(&last.span())
            } else {
                if let Some(last) = ExpList0.last() {
                    span0.merge_ordered(&last.span())
                } else {
                    span0
                }
            };
            statement::ReturnStatement::new(ExpList0, span)
        }))
    }
    fn reduce_Var_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::Ident(ident.into())
        }))
    }
    fn reduce_Var_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut rbracket) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            let span = PrefixExp.span().merge_ordered(&rbracket.span());
            Expression::TableIndex(expression::ExprTableIndex::new(PrefixExp, Exp, span))
        }))
    }
    fn reduce_Var_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            let span = PrefixExp.span().merge_ordered(&ident.span());
            let member = expression::ExprString::from(ident);
            Expression::TableIndex(expression::ExprTableIndex::new(
                PrefixExp,
                Expression::String(member),
                span,
            ))
        }))
    }
    fn reduce_PrefixExp_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut Var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7(Var))
    }
    fn reduce_PrefixExp_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant8(mut FunctionCall) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::FunctionCall(FunctionCall)
        }))
    }
    fn reduce_PrefixExp_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkOrExpressionsNodeEnum::Variant7(Exp))
    }
    fn reduce_FunctionCall_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant9(mut Args) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant8({
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, None, Args, span)
        }))
    }
    fn reduce_FunctionCall_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant9(mut Args) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant8({
            let span = PrefixExp.span().merge_ordered(&Args.span());
            expression::ExprFunctionCall::new(PrefixExp, Some(ident.into()), Args, span)
        }))
    }
    fn reduce_Args_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut lparen) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant10(mut ExpList0) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut rparen) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant9({
            let span = lparen.span().merge_ordered(&rparen.span());
            expression::FunctionCallArguments::new(ExpList0, span)
        }))
    }
    fn reduce_Args_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant15(mut TableConstructor) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant9({
            let span = TableConstructor.span();
            let table_expr = Expression::Table(TableConstructor);
            let exprs = vec![table_expr];
            expression::FunctionCallArguments::new(exprs, span)
        }))
    }
    fn reduce_Args_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut string_literal) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant9({
            let span = string_literal.span();
            let exprs = vec![Expression::String(string_literal.into())];
            expression::FunctionCallArguments::new(exprs, span)
        }))
    }
    fn reduce_VarList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant10(mut VarList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut comma) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant10({
            VarList.push(Var);
            VarList
        }))
    }
    fn reduce_VarList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut Var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant10({ vec![Var] }))
    }
    fn reduce_ExpList1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut comma) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant10({
            ExpList1.push(Exp);
            ExpList1
        }))
    }
    fn reduce_ExpList1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant10({ vec![Exp] }))
    }
    fn reduce_ExpList0_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant10(mut ExpList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant10({ ExpList1 }))
    }
    fn reduce_ExpList0_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant10({ vec![] }))
    }
    fn reduce_NameList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant11(mut NameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant11({
            NameList.push(ident.into());
            NameList
        }))
    }
    fn reduce_NameList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant11({
            vec![ident.into()]
        }))
    }
    fn reduce_AttName_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant14(mut Attrib) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant12({
            let span = ident.span();
            statement::AttName::new(ident.into(), Attrib, span)
        }))
    }
    fn reduce_AttNameList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant13(mut AttNameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant12(mut AttName) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant13({
            AttNameList.push(AttName);
            AttNameList
        }))
    }
    fn reduce_AttNameList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant12(mut AttName) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant13({ vec![AttName] }))
    }
    fn reduce_Attrib_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkOrExpressionsNodeEnum::Variant14({
            let s: SpannedString = ident.into();
            match s.as_str() {
                "const" => Some(statement::Attrib::Const),
                "close" => Some(statement::Attrib::Close),
                _ => {
                    return Err(ParseError::UnknownAttribute(s));
                }
            }
        }))
    }
    fn reduce_Attrib_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant14({ None }))
    }
    fn reduce_Exp0_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut numeric_literal) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::Numeric(numeric_literal.into())
        }))
    }
    fn reduce_Exp0_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut nil) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::Nil(nil.into())
        }))
    }
    fn reduce_Exp0_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut string_literal) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::String(string_literal.into())
        }))
    }
    fn reduce_Exp0_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut bool_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::Bool(bool_.into())
        }))
    }
    fn reduce_Exp0_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut dotdotdot) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::Variadic(dotdotdot.into())
        }))
    }
    fn reduce_Exp0_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant18(mut FunctionDef) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::Function(FunctionDef)
        }))
    }
    fn reduce_Exp0_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut PrefixExp) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7(PrefixExp))
    }
    fn reduce_Exp0_7(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant15(mut TableConstructor) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            Expression::Table(TableConstructor)
        }))
    }
    fn reduce_Exp_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp0) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7(Exp0))
    }
    fn reduce_Exp_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut not_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_unary_node!(LogicalNot, not_, Exp)
        }))
    }
    fn reduce_Exp_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut hash) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_unary_node!(Length, hash, Exp)
        }))
    }
    fn reduce_Exp_3(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut minus) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_unary_node!(Minus, minus, Exp)
        }))
    }
    fn reduce_Exp_4(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut plus) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_unary_node!(Plus, plus, Exp)
        }))
    }
    fn reduce_Exp_5(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut tilde) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_unary_node!(BitwiseNot, tilde, Exp)
        }))
    }
    fn reduce_Exp_6(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut asterisk) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Mul, asterisk, lhs, rhs)
        }))
    }
    fn reduce_Exp_7(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut slash) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Div, slash, lhs, rhs)
        }))
    }
    fn reduce_Exp_8(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut slashslash) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(FloorDiv, slashslash, lhs, rhs)
        }))
    }
    fn reduce_Exp_9(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut percent) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Mod, percent, lhs, rhs)
        }))
    }
    fn reduce_Exp_10(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut plus) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Add, plus, lhs, rhs)
        }))
    }
    fn reduce_Exp_11(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut minus) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Sub, minus, lhs, rhs)
        }))
    }
    fn reduce_Exp_12(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut dotdot) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Concat, dotdot, lhs, rhs)
        }))
    }
    fn reduce_Exp_13(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut lessless) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(ShiftLeft, lessless, lhs, rhs)
        }))
    }
    fn reduce_Exp_14(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut greatergreater) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(ShiftRight, greatergreater, lhs, rhs)
        }))
    }
    fn reduce_Exp_15(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut ampersand) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(BitwiseAnd, ampersand, lhs, rhs)
        }))
    }
    fn reduce_Exp_16(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut tilde) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(BitwiseXor, tilde, lhs, rhs)
        }))
    }
    fn reduce_Exp_17(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut pipe) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(BitwiseOr, pipe, lhs, rhs)
        }))
    }
    fn reduce_Exp_18(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut less) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(LessThan, less, lhs, rhs)
        }))
    }
    fn reduce_Exp_19(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut lessequal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(LessEqual, lessequal, lhs, rhs)
        }))
    }
    fn reduce_Exp_20(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut greater) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(GreaterThan, greater, lhs, rhs)
        }))
    }
    fn reduce_Exp_21(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut greaterequal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(GreaterEqual, greaterequal, lhs, rhs)
        }))
    }
    fn reduce_Exp_22(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut tildeequal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(NotEqual, tildeequal, lhs, rhs)
        }))
    }
    fn reduce_Exp_23(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut equalequal) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Equal, equalequal, lhs, rhs)
        }))
    }
    fn reduce_Exp_24(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut and_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(LogicalAnd, and_, lhs, rhs)
        }))
    }
    fn reduce_Exp_25(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut or_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(LogicalOr, or_, lhs, rhs)
        }))
    }
    fn reduce_Exp_26(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut lhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut caret) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut rhs) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7({
            new_binary_node!(Pow, caret, lhs, rhs)
        }))
    }
    fn reduce_TableConstructor_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut lbrace) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant16(mut FieldList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut rbrace) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant15({
            let span = lbrace.span().merge_ordered(&rbrace.span());
            expression::ExprTable::new(FieldList, span)
        }))
    }
    fn reduce_FieldList1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant16(mut FieldList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant17(mut Field) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant16({
            FieldList1.push(Field);
            FieldList1
        }))
    }
    fn reduce_FieldList1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant17(mut Field) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant16({ vec![Field] }))
    }
    fn reduce_FieldList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant16(mut FieldList1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        Ok(ChunkOrExpressionsNodeEnum::Variant16({ FieldList1 }))
    }
    fn reduce_FieldList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant16({ vec![] }))
    }
    fn reduce_Field_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut lbracket) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant7(mut k) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut v) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant17({
            let span = lbracket.span().merge_ordered(&v.span());
            expression::TableField::KeyValue(expression::TableFieldKeyValue::new(k, v, span))
        }))
    }
    fn reduce_Field_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant17({
            let span = ident.span().merge_ordered(&Exp.span());
            expression::TableField::NameValue(expression::TableFieldNameValue::new(
                ident.into(),
                Exp,
                span,
            ))
        }))
    }
    fn reduce_Field_2(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut Exp) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant17({
            expression::TableField::Value(expression::TableFieldValue::new(Exp))
        }))
    }
    fn reduce_FieldSep_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsNodeEnum::EmptyRuleType)
    }
    fn reduce_FieldSep_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsNodeEnum::EmptyRuleType)
    }
    fn reduce_FunctionDef_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut function_) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant18(mut FuncBody) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant18({
            let span = function_.span().merge_ordered(&FuncBody.span());
            FuncBody.span = span;
            FuncBody
        }))
    }
    fn reduce_FuncBody_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut lparen) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant28(mut ParList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant3(mut Block) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut end_) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant18({
            let span = lparen.span().merge_ordered(&end_.span());
            expression::ExprFunction::new(ParList, Block, span)
        }))
    }
    fn reduce_FuncName1_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant11(mut FuncName1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut dot) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant11({
            FuncName1.push(ident.into());
            FuncName1
        }))
    }
    fn reduce_FuncName1_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant11({
            vec![ident.into()]
        }))
    }
    fn reduce_FuncName_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant11(mut FuncName1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Terminals(mut ident) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant19({
            let span = FuncName1
                .first()
                .unwrap()
                .span()
                .merge_ordered(&ident.span());
            statement::FunctionName::new(FuncName1, Some(ident.into()), span)
        }))
    }
    fn reduce_FuncName_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant11(mut FuncName1) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant19({
            let span = FuncName1
                .first()
                .unwrap()
                .span()
                .merge_ordered(&FuncName1.last().unwrap().span());
            statement::FunctionName::new(FuncName1, None, span)
        }))
    }
    fn reduce_ParList_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant11(mut NameList) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant27(mut var) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant20({
            if let Some(var) = var {
                let span = NameList.first().unwrap().span().merge_ordered(&var.span());
                expression::ParameterList::new(NameList, true, span)
            } else {
                let span = NameList.first().unwrap().span();
                expression::ParameterList::new(NameList, false, span)
            }
        }))
    }
    fn reduce_ParList_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut dotdotdot) = __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant20({
            expression::ParameterList::new(Vec::new(), true, dotdotdot.span())
        }))
    }
    fn reduce__StatementPlus30_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant4(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant21({ vec![A] }))
    }
    fn reduce__StatementPlus30_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant21(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant4(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant21({
            Ap.push(A);
            Ap
        }))
    }
    fn reduce__StatementStar31_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant21(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant21({ Ap }))
    }
    fn reduce__StatementStar31_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant21({ vec![] }))
    }
    fn reduce__ReturnStatementQuestion32_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant6(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant22({ Some(A) }))
    }
    fn reduce__ReturnStatementQuestion32_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant22({ None }))
    }
    fn reduce__ElseIfPlus33_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant5(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant23({ vec![A] }))
    }
    fn reduce__ElseIfPlus33_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant23(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        let ChunkOrExpressionsNodeEnum::Variant5(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant23({
            Ap.push(A);
            Ap
        }))
    }
    fn reduce__ElseIfStar34_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant23(mut Ap) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant23({ Ap }))
    }
    fn reduce__ElseIfStar34_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant23({ vec![] }))
    }
    fn reduce__Group35_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant3(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant3(__rustylr_group_elem1))
    }
    fn reduce___Group35Question36_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant3(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant24({ Some(A) }))
    }
    fn reduce___Group35Question36_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant24({ None }))
    }
    fn reduce__Group37_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant7(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant7(__rustylr_group_elem1))
    }
    fn reduce___Group37Question38_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant7(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant25({ Some(A) }))
    }
    fn reduce___Group37Question38_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant25({ None }))
    }
    fn reduce__Group39_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Variant10(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant10(__rustylr_group_elem1))
    }
    fn reduce___Group39Question40_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant10(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant26({ Some(A) }))
    }
    fn reduce___Group39Question40_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant26({ None }))
    }
    fn reduce__semicolonQuestion41_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant27({ Some(A) }))
    }
    fn reduce__semicolonQuestion41_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant27({ None }))
    }
    fn reduce__FieldSepQuestion42_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsNodeEnum::EmptyRuleType)
    }
    fn reduce__FieldSepQuestion42_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsNodeEnum::EmptyRuleType)
    }
    fn reduce__ParListQuestion43_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Variant20(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant28({ Some(A) }))
    }
    fn reduce__ParListQuestion43_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant28({ None }))
    }
    fn reduce__Group44_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.pop();
        let ChunkOrExpressionsNodeEnum::Terminals(mut __rustylr_group_elem1) =
            __rustylr_args.pop().unwrap()
        else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Terminals(__rustylr_group_elem1))
    }
    fn reduce___Group44Question45_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        let ChunkOrExpressionsNodeEnum::Terminals(mut A) = __rustylr_args.pop().unwrap() else {
            unreachable!()
        };
        Ok(ChunkOrExpressionsNodeEnum::Variant27({ Some(A) }))
    }
    fn reduce___Group44Question45_1(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        Ok(ChunkOrExpressionsNodeEnum::Variant27({ None }))
    }
    fn reduce_Augmented_0(
        __rustylr_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Token,
        data: &mut (),
    ) -> Result<ChunkOrExpressionsNodeEnum, ParseError> {
        __rustylr_args.clear();
        Ok(ChunkOrExpressionsNodeEnum::EmptyRuleType)
    }
}
#[allow(
    unused_braces,
    unused_parens,
    non_snake_case,
    non_camel_case_types,
    unused_variables
)]
impl ::rusty_lr::glr::NodeData for ChunkOrExpressionsNodeEnum {
    type Term = Token;
    type NonTerm = ChunkOrExpressionsNonTerminals;
    type ReduceActionError = ParseError;
    type UserData = ();
    type StartType = ChunkOrExpressions;
    fn new_term(term: Token) -> Self {
        ChunkOrExpressionsNodeEnum::Terminals(term)
    }
    fn new_nonterm(
        rule_index: usize,
        reduce_args: &mut Vec<Self>,
        shift: &mut bool,
        lookahead: &Self::Term,
        user_data: &mut Self::UserData,
    ) -> Result<Self, Self::ReduceActionError> {
        match rule_index {
            0usize => Self::reduce_ChunkOrExpressions_0(reduce_args, shift, lookahead, user_data),
            1usize => Self::reduce_ChunkOrExpressions_1(reduce_args, shift, lookahead, user_data),
            2usize => Self::reduce_Chunk_0(reduce_args, shift, lookahead, user_data),
            3usize => Self::reduce_Block_0(reduce_args, shift, lookahead, user_data),
            4usize => Self::reduce_Statement_0(reduce_args, shift, lookahead, user_data),
            5usize => Self::reduce_Statement_1(reduce_args, shift, lookahead, user_data),
            6usize => Self::reduce_Statement_2(reduce_args, shift, lookahead, user_data),
            7usize => Self::reduce_Statement_3(reduce_args, shift, lookahead, user_data),
            8usize => Self::reduce_Statement_4(reduce_args, shift, lookahead, user_data),
            9usize => Self::reduce_Statement_5(reduce_args, shift, lookahead, user_data),
            10usize => Self::reduce_Statement_6(reduce_args, shift, lookahead, user_data),
            11usize => Self::reduce_Statement_7(reduce_args, shift, lookahead, user_data),
            12usize => Self::reduce_Statement_8(reduce_args, shift, lookahead, user_data),
            13usize => Self::reduce_Statement_9(reduce_args, shift, lookahead, user_data),
            14usize => Self::reduce_Statement_10(reduce_args, shift, lookahead, user_data),
            15usize => Self::reduce_Statement_11(reduce_args, shift, lookahead, user_data),
            16usize => Self::reduce_Statement_12(reduce_args, shift, lookahead, user_data),
            17usize => Self::reduce_Statement_13(reduce_args, shift, lookahead, user_data),
            18usize => Self::reduce_Statement_14(reduce_args, shift, lookahead, user_data),
            19usize => Self::reduce_ElseIf_0(reduce_args, shift, lookahead, user_data),
            20usize => Self::reduce_ReturnStatement_0(reduce_args, shift, lookahead, user_data),
            21usize => Self::reduce_Var_0(reduce_args, shift, lookahead, user_data),
            22usize => Self::reduce_Var_1(reduce_args, shift, lookahead, user_data),
            23usize => Self::reduce_Var_2(reduce_args, shift, lookahead, user_data),
            24usize => Self::reduce_PrefixExp_0(reduce_args, shift, lookahead, user_data),
            25usize => Self::reduce_PrefixExp_1(reduce_args, shift, lookahead, user_data),
            26usize => Self::reduce_PrefixExp_2(reduce_args, shift, lookahead, user_data),
            27usize => Self::reduce_FunctionCall_0(reduce_args, shift, lookahead, user_data),
            28usize => Self::reduce_FunctionCall_1(reduce_args, shift, lookahead, user_data),
            29usize => Self::reduce_Args_0(reduce_args, shift, lookahead, user_data),
            30usize => Self::reduce_Args_1(reduce_args, shift, lookahead, user_data),
            31usize => Self::reduce_Args_2(reduce_args, shift, lookahead, user_data),
            32usize => Self::reduce_VarList_0(reduce_args, shift, lookahead, user_data),
            33usize => Self::reduce_VarList_1(reduce_args, shift, lookahead, user_data),
            34usize => Self::reduce_ExpList1_0(reduce_args, shift, lookahead, user_data),
            35usize => Self::reduce_ExpList1_1(reduce_args, shift, lookahead, user_data),
            36usize => Self::reduce_ExpList0_0(reduce_args, shift, lookahead, user_data),
            37usize => Self::reduce_ExpList0_1(reduce_args, shift, lookahead, user_data),
            38usize => Self::reduce_NameList_0(reduce_args, shift, lookahead, user_data),
            39usize => Self::reduce_NameList_1(reduce_args, shift, lookahead, user_data),
            40usize => Self::reduce_AttName_0(reduce_args, shift, lookahead, user_data),
            41usize => Self::reduce_AttNameList_0(reduce_args, shift, lookahead, user_data),
            42usize => Self::reduce_AttNameList_1(reduce_args, shift, lookahead, user_data),
            43usize => Self::reduce_Attrib_0(reduce_args, shift, lookahead, user_data),
            44usize => Self::reduce_Attrib_1(reduce_args, shift, lookahead, user_data),
            45usize => Self::reduce_Exp0_0(reduce_args, shift, lookahead, user_data),
            46usize => Self::reduce_Exp0_1(reduce_args, shift, lookahead, user_data),
            47usize => Self::reduce_Exp0_2(reduce_args, shift, lookahead, user_data),
            48usize => Self::reduce_Exp0_3(reduce_args, shift, lookahead, user_data),
            49usize => Self::reduce_Exp0_4(reduce_args, shift, lookahead, user_data),
            50usize => Self::reduce_Exp0_5(reduce_args, shift, lookahead, user_data),
            51usize => Self::reduce_Exp0_6(reduce_args, shift, lookahead, user_data),
            52usize => Self::reduce_Exp0_7(reduce_args, shift, lookahead, user_data),
            53usize => Self::reduce_Exp_0(reduce_args, shift, lookahead, user_data),
            54usize => Self::reduce_Exp_1(reduce_args, shift, lookahead, user_data),
            55usize => Self::reduce_Exp_2(reduce_args, shift, lookahead, user_data),
            56usize => Self::reduce_Exp_3(reduce_args, shift, lookahead, user_data),
            57usize => Self::reduce_Exp_4(reduce_args, shift, lookahead, user_data),
            58usize => Self::reduce_Exp_5(reduce_args, shift, lookahead, user_data),
            59usize => Self::reduce_Exp_6(reduce_args, shift, lookahead, user_data),
            60usize => Self::reduce_Exp_7(reduce_args, shift, lookahead, user_data),
            61usize => Self::reduce_Exp_8(reduce_args, shift, lookahead, user_data),
            62usize => Self::reduce_Exp_9(reduce_args, shift, lookahead, user_data),
            63usize => Self::reduce_Exp_10(reduce_args, shift, lookahead, user_data),
            64usize => Self::reduce_Exp_11(reduce_args, shift, lookahead, user_data),
            65usize => Self::reduce_Exp_12(reduce_args, shift, lookahead, user_data),
            66usize => Self::reduce_Exp_13(reduce_args, shift, lookahead, user_data),
            67usize => Self::reduce_Exp_14(reduce_args, shift, lookahead, user_data),
            68usize => Self::reduce_Exp_15(reduce_args, shift, lookahead, user_data),
            69usize => Self::reduce_Exp_16(reduce_args, shift, lookahead, user_data),
            70usize => Self::reduce_Exp_17(reduce_args, shift, lookahead, user_data),
            71usize => Self::reduce_Exp_18(reduce_args, shift, lookahead, user_data),
            72usize => Self::reduce_Exp_19(reduce_args, shift, lookahead, user_data),
            73usize => Self::reduce_Exp_20(reduce_args, shift, lookahead, user_data),
            74usize => Self::reduce_Exp_21(reduce_args, shift, lookahead, user_data),
            75usize => Self::reduce_Exp_22(reduce_args, shift, lookahead, user_data),
            76usize => Self::reduce_Exp_23(reduce_args, shift, lookahead, user_data),
            77usize => Self::reduce_Exp_24(reduce_args, shift, lookahead, user_data),
            78usize => Self::reduce_Exp_25(reduce_args, shift, lookahead, user_data),
            79usize => Self::reduce_Exp_26(reduce_args, shift, lookahead, user_data),
            80usize => Self::reduce_TableConstructor_0(reduce_args, shift, lookahead, user_data),
            81usize => Self::reduce_FieldList1_0(reduce_args, shift, lookahead, user_data),
            82usize => Self::reduce_FieldList1_1(reduce_args, shift, lookahead, user_data),
            83usize => Self::reduce_FieldList_0(reduce_args, shift, lookahead, user_data),
            84usize => Self::reduce_FieldList_1(reduce_args, shift, lookahead, user_data),
            85usize => Self::reduce_Field_0(reduce_args, shift, lookahead, user_data),
            86usize => Self::reduce_Field_1(reduce_args, shift, lookahead, user_data),
            87usize => Self::reduce_Field_2(reduce_args, shift, lookahead, user_data),
            88usize => Self::reduce_FieldSep_0(reduce_args, shift, lookahead, user_data),
            89usize => Self::reduce_FieldSep_1(reduce_args, shift, lookahead, user_data),
            90usize => Self::reduce_FunctionDef_0(reduce_args, shift, lookahead, user_data),
            91usize => Self::reduce_FuncBody_0(reduce_args, shift, lookahead, user_data),
            92usize => Self::reduce_FuncName1_0(reduce_args, shift, lookahead, user_data),
            93usize => Self::reduce_FuncName1_1(reduce_args, shift, lookahead, user_data),
            94usize => Self::reduce_FuncName_0(reduce_args, shift, lookahead, user_data),
            95usize => Self::reduce_FuncName_1(reduce_args, shift, lookahead, user_data),
            96usize => Self::reduce_ParList_0(reduce_args, shift, lookahead, user_data),
            97usize => Self::reduce_ParList_1(reduce_args, shift, lookahead, user_data),
            98usize => Self::reduce__StatementPlus30_0(reduce_args, shift, lookahead, user_data),
            99usize => Self::reduce__StatementPlus30_1(reduce_args, shift, lookahead, user_data),
            100usize => Self::reduce__StatementStar31_0(reduce_args, shift, lookahead, user_data),
            101usize => Self::reduce__StatementStar31_1(reduce_args, shift, lookahead, user_data),
            102usize => {
                Self::reduce__ReturnStatementQuestion32_0(reduce_args, shift, lookahead, user_data)
            }
            103usize => {
                Self::reduce__ReturnStatementQuestion32_1(reduce_args, shift, lookahead, user_data)
            }
            104usize => Self::reduce__ElseIfPlus33_0(reduce_args, shift, lookahead, user_data),
            105usize => Self::reduce__ElseIfPlus33_1(reduce_args, shift, lookahead, user_data),
            106usize => Self::reduce__ElseIfStar34_0(reduce_args, shift, lookahead, user_data),
            107usize => Self::reduce__ElseIfStar34_1(reduce_args, shift, lookahead, user_data),
            108usize => Self::reduce__Group35_0(reduce_args, shift, lookahead, user_data),
            109usize => {
                Self::reduce___Group35Question36_0(reduce_args, shift, lookahead, user_data)
            }
            110usize => {
                Self::reduce___Group35Question36_1(reduce_args, shift, lookahead, user_data)
            }
            111usize => Self::reduce__Group37_0(reduce_args, shift, lookahead, user_data),
            112usize => {
                Self::reduce___Group37Question38_0(reduce_args, shift, lookahead, user_data)
            }
            113usize => {
                Self::reduce___Group37Question38_1(reduce_args, shift, lookahead, user_data)
            }
            114usize => Self::reduce__Group39_0(reduce_args, shift, lookahead, user_data),
            115usize => {
                Self::reduce___Group39Question40_0(reduce_args, shift, lookahead, user_data)
            }
            116usize => {
                Self::reduce___Group39Question40_1(reduce_args, shift, lookahead, user_data)
            }
            117usize => {
                Self::reduce__semicolonQuestion41_0(reduce_args, shift, lookahead, user_data)
            }
            118usize => {
                Self::reduce__semicolonQuestion41_1(reduce_args, shift, lookahead, user_data)
            }
            119usize => {
                Self::reduce__FieldSepQuestion42_0(reduce_args, shift, lookahead, user_data)
            }
            120usize => {
                Self::reduce__FieldSepQuestion42_1(reduce_args, shift, lookahead, user_data)
            }
            121usize => Self::reduce__ParListQuestion43_0(reduce_args, shift, lookahead, user_data),
            122usize => Self::reduce__ParListQuestion43_1(reduce_args, shift, lookahead, user_data),
            123usize => Self::reduce__Group44_0(reduce_args, shift, lookahead, user_data),
            124usize => {
                Self::reduce___Group44Question45_0(reduce_args, shift, lookahead, user_data)
            }
            125usize => {
                Self::reduce___Group44Question45_1(reduce_args, shift, lookahead, user_data)
            }
            126usize => Self::reduce_Augmented_0(reduce_args, shift, lookahead, user_data),
            _ => {
                unreachable!("Invalid Rule: {}", rule_index);
            }
        }
    }
    fn into_start(self) -> Self::StartType {
        match self {
            ChunkOrExpressionsNodeEnum::Variant2(start) => start,
            _ => unreachable!(),
        }
    }
    fn new_error_nonterm() -> Self {
        ChunkOrExpressionsNodeEnum::EmptyRuleType
    }
}
#[doc = r" A struct that holds the entire parser table and production rules."]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
pub struct ChunkOrExpressionsParser {
    #[doc = r" production rules"]
    pub rules: Vec<ChunkOrExpressionsRule>,
    #[doc = r" states"]
    pub states: Vec<ChunkOrExpressionsState>,
    #[doc = r" terminal classes"]
    pub classes: Vec<Vec<Token>>,
    #[doc = r" term to class map"]
    pub term_class_map: ::rusty_lr::HashMap<Token, usize>,
    #[doc = r" class id for terminal not matched with any in grammar"]
    pub other_class_id: usize,
}
impl ::rusty_lr::glr::Parser for ChunkOrExpressionsParser {
    type Term = Token;
    type NonTerm = ChunkOrExpressionsNonTerminals;
    type TermRet<'a> = &'a Token;
    type State = ChunkOrExpressionsState;
    fn get_rules(&self) -> &[ChunkOrExpressionsRule] {
        &self.rules
    }
    fn get_states(&self) -> &[ChunkOrExpressionsState] {
        &self.states
    }
    fn get_terminals(&self, i: usize) -> Option<impl IntoIterator<Item = Self::TermRet<'_>> + '_> {
        self.classes.get(i)
    }
    fn to_terminal_class(&self, terminal: &Self::Term) -> usize {
        self.term_class_map
            .get(terminal)
            .copied()
            .unwrap_or(self.other_class_id)
    }
    fn get_error_nonterm(&self) -> Option<Self::NonTerm> {
        None
    }
}
#[doc = r" A struct that holds the whole parser table."]
#[allow(
    unused_braces,
    unused_parens,
    unused_variables,
    non_snake_case,
    unused_mut
)]
impl ChunkOrExpressionsParser {
    #[doc = r" Calculates the states and parser tables from the grammar."]
    #[allow(clippy::clone_on_copy)]
    pub fn new() -> Self {
        let mut builder = ::rusty_lr::builder::Grammar::new();
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(22usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(14usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(25usize),
            ::rusty_lr::ReduceType::Right,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(6usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(17usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(36usize),
            ::rusty_lr::ReduceType::Right,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(9usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(20usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(12usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(23usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(15usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(7usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(18usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(51usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(10usize),
            ::rusty_lr::ReduceType::Right,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(21usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(13usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(5usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(16usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(38usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(8usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_reduce_type(
            ::rusty_lr::builder::Operator::Term(19usize),
            ::rusty_lr::ReduceType::Left,
        );
        builder.add_precedence(::rusty_lr::builder::Operator::Term(22usize), 3usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(14usize), 4usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(25usize), 0usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(36usize), 8usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(6usize), 9usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(17usize), 10usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(9usize), 10usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(20usize), 3usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(2usize), 12usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(12usize), 6usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(23usize), 3usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(0usize), 12usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(15usize), 7usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(3usize), 12usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(18usize), 3usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(51usize), 1usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(7usize), 10usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(21usize), 3usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(10usize), 11usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(13usize), 5usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(1usize), 12usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(16usize), 7usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(38usize), 2usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(5usize), 9usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(19usize), 3usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Term(8usize), 10usize);
        builder.add_precedence(::rusty_lr::builder::Operator::Prec(4usize), 12usize);
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Chunk,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ChunkOrExpressions,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ExpList1,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Chunk,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Block,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Block,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_StatementStar31),
                ::rusty_lr::Token::NonTerm(
                    ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion32,
                ),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![::rusty_lr::Token::Term(32usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::VarList),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FunctionCall,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(31usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(31usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![::rusty_lr::Token::Term(39usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(46usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(56usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(52usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(55usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(47usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(54usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ElseIfStar34),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group35Question36),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(44usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group37Question38),
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(44usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
                ::rusty_lr::Token::Term(48usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
                ::rusty_lr::Token::Term(40usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(45usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(49usize),
                ::rusty_lr::Token::Term(45usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Statement,
            vec![
                ::rusty_lr::Token::Term(49usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttNameList),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group39Question40),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ElseIf,
            vec![
                ::rusty_lr::Token::Term(42usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(54usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ReturnStatement,
            vec![
                ::rusty_lr::Token::Term(53usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList0),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_semicolonQuestion41),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Var,
            vec![::rusty_lr::Token::Term(0usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Var,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(29usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(30usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Var,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(35usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::PrefixExp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Var,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::PrefixExp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FunctionCall,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::PrefixExp,
            vec![
                ::rusty_lr::Token::Term(25usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(26usize),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(25usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FunctionCall,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Args),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FunctionCall,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::PrefixExp),
                ::rusty_lr::Token::Term(33usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Args),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Args,
            vec![
                ::rusty_lr::Token::Term(25usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList0),
                ::rusty_lr::Token::Term(26usize),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(25usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Args,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::TableConstructor,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Args,
            vec![::rusty_lr::Token::Term(1usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::VarList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::VarList),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Var),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::VarList,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Var,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList1,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList1,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Exp,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList0,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ExpList1,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ExpList0,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::NameList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::NameList,
            vec![::rusty_lr::Token::Term(0usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::AttName,
            vec![
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Attrib),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::AttNameList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttNameList),
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::AttName),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::AttNameList,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::AttName,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Attrib,
            vec![
                ::rusty_lr::Token::Term(22usize),
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(23usize),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(22usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Attrib,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::Term(2usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::Term(3usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::Term(1usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::Term(4usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::Term(37usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FunctionDef,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::PrefixExp,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp0,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::TableConstructor,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Exp0,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(50usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(0usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(11usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(1usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(6usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(2usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(5usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(3usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::Term(13usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Prec(4usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(7usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(7usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(8usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(8usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(17usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(17usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(9usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(9usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(5usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(5usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(6usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(6usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(36usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(36usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(15usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(15usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(16usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(16usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(12usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(12usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(13usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(13usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(14usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(14usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(22usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(22usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(20usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(20usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(23usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(23usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(21usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(21usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(19usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(19usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(18usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(18usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(38usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(38usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(51usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(51usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Exp,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(10usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(10usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::TableConstructor,
            vec![
                ::rusty_lr::Token::Term(27usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldList),
                ::rusty_lr::Token::Term(28usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList1,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldList1),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldSep),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Field),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList1,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Field,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FieldList1),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_FieldSepQuestion42),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldList,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Field,
            vec![
                ::rusty_lr::Token::Term(29usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
                ::rusty_lr::Token::Term(30usize),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Field,
            vec![
                ::rusty_lr::Token::Term(0usize),
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Field,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Exp,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldSep,
            vec![::rusty_lr::Token::Term(34usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FieldSep,
            vec![::rusty_lr::Token::Term(32usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FunctionDef,
            vec![
                ::rusty_lr::Token::Term(45usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncBody),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncBody,
            vec![
                ::rusty_lr::Token::Term(25usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ParListQuestion43),
                ::rusty_lr::Token::Term(26usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
                ::rusty_lr::Token::Term(43usize),
            ],
            None,
            Some(::rusty_lr::builder::Operator::Term(25usize)),
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName1,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName1),
                ::rusty_lr::Token::Term(35usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName1,
            vec![::rusty_lr::Token::Term(0usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::FuncName1),
                ::rusty_lr::Token::Term(33usize),
                ::rusty_lr::Token::Term(0usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::FuncName,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FuncName1,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ParList,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::NameList),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::__Group44Question45),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::ParList,
            vec![::rusty_lr::Token::Term(37usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementPlus30,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::Statement,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementPlus30,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_StatementPlus30),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Statement),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementStar31,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_StatementPlus30,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_StatementStar31,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion32,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ReturnStatement,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ReturnStatementQuestion32,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfPlus33,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ElseIf,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfPlus33,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::_ElseIfPlus33),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ElseIf),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfStar34,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_ElseIfPlus33,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ElseIfStar34,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group35,
            vec![
                ::rusty_lr::Token::Term(41usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Block),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group35Question36,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group35,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group35Question36,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group37,
            vec![
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::Exp),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group37Question38,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group37,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group37Question38,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group39,
            vec![
                ::rusty_lr::Token::Term(24usize),
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ExpList1),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group39Question40,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group39,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group39Question40,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_semicolonQuestion41,
            vec![::rusty_lr::Token::Term(32usize)],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_semicolonQuestion41,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion42,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::FieldSep,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_FieldSepQuestion42,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ParListQuestion43,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::ParList,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_ParListQuestion43,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::_Group44,
            vec![
                ::rusty_lr::Token::Term(34usize),
                ::rusty_lr::Token::Term(37usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group44Question45,
            vec![::rusty_lr::Token::NonTerm(
                ChunkOrExpressionsNonTerminals::_Group44,
            )],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::__Group44Question45,
            vec![],
            None,
            None,
            0usize,
        );
        builder.add_rule(
            ChunkOrExpressionsNonTerminals::Augmented,
            vec![
                ::rusty_lr::Token::NonTerm(ChunkOrExpressionsNonTerminals::ChunkOrExpressions),
                ::rusty_lr::Token::Term(57usize),
            ],
            None,
            None,
            0usize,
        );
        builder.add_empty_rule(ChunkOrExpressionsNonTerminals::error);
        let Ok(states) = builder.build_lalr(
            ChunkOrExpressionsNonTerminals::Augmented,
            &mut ::rusty_lr::builder::DiagnosticCollector::new(false),
        ) else {
            unreachable!("Failed to build LALR parser")
        };
        let states = states.states;
        let terminal_class_names = vec![
            "ident",
            "string_literal",
            "numeric_literal",
            "nil",
            "bool_",
            "plus",
            "minus",
            "asterisk",
            "slash",
            "percent",
            "caret",
            "hash",
            "ampersand",
            "tilde",
            "pipe",
            "lessless",
            "greatergreater",
            "slashslash",
            "equalequal",
            "tildeequal",
            "lessequal",
            "greaterequal",
            "less",
            "greater",
            "equal",
            "lparen",
            "rparen",
            "lbrace",
            "rbrace",
            "lbracket",
            "rbracket",
            "coloncolon",
            "semicolon",
            "colon",
            "comma",
            "dot",
            "dotdot",
            "dotdotdot",
            "and_",
            "break_",
            "do_",
            "else_",
            "elseif_",
            "end_",
            "for_",
            "function_",
            "goto_",
            "if_",
            "in_",
            "local_",
            "not_",
            "or_",
            "repeat_",
            "return_",
            "then_",
            "until_",
            "while_",
            "eof",
            "<Others>",
        ];
        let rules = builder
            .rules
            .into_iter()
            .map(move |rule| {
                rule.rule
                    .map(|term| terminal_class_names[term], |nonterm| nonterm)
            })
            .collect();
        let states: Vec<_> = states
            .into_iter()
            .map(|state| state.into_glr_sparse_state(|x| x, |x| x))
            .collect();
        let mut terminals_class_map: ::rusty_lr::HashMap<Token, usize> = Default::default();
        terminals_class_map.insert(Token::new_type(TokenType::Ident("".to_string())), 0usize);
        terminals_class_map.insert(Token::new_type(TokenType::String(vec![])), 1usize);
        terminals_class_map.insert(
            Token::new_type(TokenType::Numeric(IntOrFloat::Int(0))),
            2usize,
        );
        terminals_class_map.insert(Token::new_type(TokenType::Nil), 3usize);
        terminals_class_map.insert(Token::new_type(TokenType::Bool(false)), 4usize);
        terminals_class_map.insert(Token::new_type(TokenType::Plus), 5usize);
        terminals_class_map.insert(Token::new_type(TokenType::Minus), 6usize);
        terminals_class_map.insert(Token::new_type(TokenType::Asterisk), 7usize);
        terminals_class_map.insert(Token::new_type(TokenType::Slash), 8usize);
        terminals_class_map.insert(Token::new_type(TokenType::Percent), 9usize);
        terminals_class_map.insert(Token::new_type(TokenType::Caret), 10usize);
        terminals_class_map.insert(Token::new_type(TokenType::Hash), 11usize);
        terminals_class_map.insert(Token::new_type(TokenType::Ampersand), 12usize);
        terminals_class_map.insert(Token::new_type(TokenType::Tilde), 13usize);
        terminals_class_map.insert(Token::new_type(TokenType::Pipe), 14usize);
        terminals_class_map.insert(Token::new_type(TokenType::LessLess), 15usize);
        terminals_class_map.insert(Token::new_type(TokenType::GreaterGreater), 16usize);
        terminals_class_map.insert(Token::new_type(TokenType::SlashSlash), 17usize);
        terminals_class_map.insert(Token::new_type(TokenType::EqualEqual), 18usize);
        terminals_class_map.insert(Token::new_type(TokenType::TildeEqual), 19usize);
        terminals_class_map.insert(Token::new_type(TokenType::LessEqual), 20usize);
        terminals_class_map.insert(Token::new_type(TokenType::GreaterEqual), 21usize);
        terminals_class_map.insert(Token::new_type(TokenType::Less), 22usize);
        terminals_class_map.insert(Token::new_type(TokenType::Greater), 23usize);
        terminals_class_map.insert(Token::new_type(TokenType::Equal), 24usize);
        terminals_class_map.insert(Token::new_type(TokenType::LParen), 25usize);
        terminals_class_map.insert(Token::new_type(TokenType::RParen), 26usize);
        terminals_class_map.insert(Token::new_type(TokenType::LBrace), 27usize);
        terminals_class_map.insert(Token::new_type(TokenType::RBrace), 28usize);
        terminals_class_map.insert(Token::new_type(TokenType::LBracket), 29usize);
        terminals_class_map.insert(Token::new_type(TokenType::RBracket), 30usize);
        terminals_class_map.insert(Token::new_type(TokenType::ColonColon), 31usize);
        terminals_class_map.insert(Token::new_type(TokenType::Semicolon), 32usize);
        terminals_class_map.insert(Token::new_type(TokenType::Colon), 33usize);
        terminals_class_map.insert(Token::new_type(TokenType::Comma), 34usize);
        terminals_class_map.insert(Token::new_type(TokenType::Dot), 35usize);
        terminals_class_map.insert(Token::new_type(TokenType::DotDot), 36usize);
        terminals_class_map.insert(Token::new_type(TokenType::DotDotDot), 37usize);
        terminals_class_map.insert(Token::new_type(TokenType::And), 38usize);
        terminals_class_map.insert(Token::new_type(TokenType::Break), 39usize);
        terminals_class_map.insert(Token::new_type(TokenType::Do), 40usize);
        terminals_class_map.insert(Token::new_type(TokenType::Else), 41usize);
        terminals_class_map.insert(Token::new_type(TokenType::Elseif), 42usize);
        terminals_class_map.insert(Token::new_type(TokenType::End), 43usize);
        terminals_class_map.insert(Token::new_type(TokenType::For), 44usize);
        terminals_class_map.insert(Token::new_type(TokenType::Function), 45usize);
        terminals_class_map.insert(Token::new_type(TokenType::Goto), 46usize);
        terminals_class_map.insert(Token::new_type(TokenType::If), 47usize);
        terminals_class_map.insert(Token::new_type(TokenType::In), 48usize);
        terminals_class_map.insert(Token::new_type(TokenType::Local), 49usize);
        terminals_class_map.insert(Token::new_type(TokenType::Not), 50usize);
        terminals_class_map.insert(Token::new_type(TokenType::Or), 51usize);
        terminals_class_map.insert(Token::new_type(TokenType::Repeat), 52usize);
        terminals_class_map.insert(Token::new_type(TokenType::Return), 53usize);
        terminals_class_map.insert(Token::new_type(TokenType::Then), 54usize);
        terminals_class_map.insert(Token::new_type(TokenType::Until), 55usize);
        terminals_class_map.insert(Token::new_type(TokenType::While), 56usize);
        terminals_class_map.insert(Token::new_type(TokenType::Eof), 57usize);
        let terminal_classes = vec![
            vec![Token::new_type(TokenType::Ident("".to_string()))],
            vec![Token::new_type(TokenType::String(vec![]))],
            vec![Token::new_type(TokenType::Numeric(IntOrFloat::Int(0)))],
            vec![Token::new_type(TokenType::Nil)],
            vec![Token::new_type(TokenType::Bool(false))],
            vec![Token::new_type(TokenType::Plus)],
            vec![Token::new_type(TokenType::Minus)],
            vec![Token::new_type(TokenType::Asterisk)],
            vec![Token::new_type(TokenType::Slash)],
            vec![Token::new_type(TokenType::Percent)],
            vec![Token::new_type(TokenType::Caret)],
            vec![Token::new_type(TokenType::Hash)],
            vec![Token::new_type(TokenType::Ampersand)],
            vec![Token::new_type(TokenType::Tilde)],
            vec![Token::new_type(TokenType::Pipe)],
            vec![Token::new_type(TokenType::LessLess)],
            vec![Token::new_type(TokenType::GreaterGreater)],
            vec![Token::new_type(TokenType::SlashSlash)],
            vec![Token::new_type(TokenType::EqualEqual)],
            vec![Token::new_type(TokenType::TildeEqual)],
            vec![Token::new_type(TokenType::LessEqual)],
            vec![Token::new_type(TokenType::GreaterEqual)],
            vec![Token::new_type(TokenType::Less)],
            vec![Token::new_type(TokenType::Greater)],
            vec![Token::new_type(TokenType::Equal)],
            vec![Token::new_type(TokenType::LParen)],
            vec![Token::new_type(TokenType::RParen)],
            vec![Token::new_type(TokenType::LBrace)],
            vec![Token::new_type(TokenType::RBrace)],
            vec![Token::new_type(TokenType::LBracket)],
            vec![Token::new_type(TokenType::RBracket)],
            vec![Token::new_type(TokenType::ColonColon)],
            vec![Token::new_type(TokenType::Semicolon)],
            vec![Token::new_type(TokenType::Colon)],
            vec![Token::new_type(TokenType::Comma)],
            vec![Token::new_type(TokenType::Dot)],
            vec![Token::new_type(TokenType::DotDot)],
            vec![Token::new_type(TokenType::DotDotDot)],
            vec![Token::new_type(TokenType::And)],
            vec![Token::new_type(TokenType::Break)],
            vec![Token::new_type(TokenType::Do)],
            vec![Token::new_type(TokenType::Else)],
            vec![Token::new_type(TokenType::Elseif)],
            vec![Token::new_type(TokenType::End)],
            vec![Token::new_type(TokenType::For)],
            vec![Token::new_type(TokenType::Function)],
            vec![Token::new_type(TokenType::Goto)],
            vec![Token::new_type(TokenType::If)],
            vec![Token::new_type(TokenType::In)],
            vec![Token::new_type(TokenType::Local)],
            vec![Token::new_type(TokenType::Not)],
            vec![Token::new_type(TokenType::Or)],
            vec![Token::new_type(TokenType::Repeat)],
            vec![Token::new_type(TokenType::Return)],
            vec![Token::new_type(TokenType::Then)],
            vec![Token::new_type(TokenType::Until)],
            vec![Token::new_type(TokenType::While)],
            vec![Token::new_type(TokenType::Eof)],
            vec![],
        ];
        Self {
            rules,
            states,
            classes: terminal_classes,
            term_class_map: terminals_class_map,
            other_class_id: 58usize,
        }
    }
}
// ==============================Generated Codes End===============================
